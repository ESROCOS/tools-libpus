/* Body file for function PusServices
 * Generated by TASTE on 2021-07-05 17:17:23
 * You can edit this file, it will not be overwritten
 * Provided interfaces : ack, addTc, addTm, getOnBoardParam, getParamValue, newTc, pushNewEvent, setOnBoardParam, setParamValue, trigger
 * Required interfaces : forwardTc, newTm
 * User-defined properties for this function:
 *   |_ Taste::Active_Interfaces = any
 *   |_ Taste::coordinates = 133885 62204 179396 91179
 * Timers              : 
 */
#include <stdlib.h>
#ifdef __unix__
   #include <stdio.h>
   #include "PrintTypesAsASN1.h"
   #include "timeInMS.h"
#endif
#include "C_ASN1_Types.h"
#include "dataview-uniq.h"

// reference to flag preventing calls to RIs during the startup transition
extern unsigned pusservices_initialized;
// in case that happens, use system's abort function to crash the application
extern void abort (void);

void pusservices_RI_forwardTc
      (const asn1SccPusPacket *IN_tcpacket)

{
   // Check that we are not in the startup transition
   if (2 != pusservices_initialized) {
      #ifdef __unix__
         puts("A call to pusservices_RI_forwardTc was made during system startup.");
         puts("This is not allowed because the system is not yet fully initialized. Please fix your code/models");
      #endif
      // crash the application
      abort();
   }

   #ifdef __unix__
      // Log MSC data on Linux when environment variable is set
      static int innerMsc = -1;
      if (-1 == innerMsc)
         innerMsc = (NULL != getenv("TASTE_INNER_MSC"))?1:0;
      if (1 == innerMsc) {
         long long msc_time = getTimeInMilliseconds();
         PrintASN1PusPacket ("INNERDATA: forwardtc::PusPacket::tcpacket", IN_tcpacket);
         puts(""); // add newline
         // Log message to DummyPrivateService (corresponding PI: forwardTc)
         printf ("INNER: pusservices,dummyprivateservice,forwardtc,%lld\n", msc_time);
         fflush(stdout);
      }
   #endif
   // Encode parameter tcPacket
   static asn1SccPusPacket IN_buf_tcpacket;
   int size_IN_buf_tcpacket =
      Encode_NATIVE_PusPacket
        ((void *)&IN_buf_tcpacket,
          sizeof(asn1SccPusPacket),
          (asn1SccPusPacket *)IN_tcpacket);
   if (-1 == size_IN_buf_tcpacket) {
      #ifdef __unix__
         puts ("[ERROR] ASN.1 Encoding failed in pusservices_RI_forwardTc, parameter tcPacket");
      #endif
        /* Crash the application due to message loss */
        abort();
   }


   // Call Middleware interface
   extern void vm_pusservices_forwardtc
     (void *, size_t);

   vm_pusservices_forwardtc
     ((void *)&IN_buf_tcpacket, (size_t)size_IN_buf_tcpacket);


}void pusservices_RI_newTm
      (const asn1SccPusPacket *IN_tmpacket)

{
   // Check that we are not in the startup transition
   if (2 != pusservices_initialized) {
      #ifdef __unix__
         puts("A call to pusservices_RI_newTm was made during system startup.");
         puts("This is not allowed because the system is not yet fully initialized. Please fix your code/models");
      #endif
      // crash the application
      abort();
   }

   #ifdef __unix__
      // Log MSC data on Linux when environment variable is set
      static int innerMsc = -1;
      if (-1 == innerMsc)
         innerMsc = (NULL != getenv("TASTE_INNER_MSC"))?1:0;
      if (1 == innerMsc) {
         long long msc_time = getTimeInMilliseconds();
         PrintASN1PusPacket ("INNERDATA: newtm::PusPacket::tmpacket", IN_tmpacket);
         puts(""); // add newline
         // Log message to Ground (corresponding PI: newTm)
         printf ("INNER: pusservices,ground,newtm,%lld\n", msc_time);
         fflush(stdout);
      }
   #endif
   // Encode parameter tmPacket
   static asn1SccPusPacket IN_buf_tmpacket;
   int size_IN_buf_tmpacket =
      Encode_NATIVE_PusPacket
        ((void *)&IN_buf_tmpacket,
          sizeof(asn1SccPusPacket),
          (asn1SccPusPacket *)IN_tmpacket);
   if (-1 == size_IN_buf_tmpacket) {
      #ifdef __unix__
         puts ("[ERROR] ASN.1 Encoding failed in pusservices_RI_newTm, parameter tmPacket");
      #endif
        /* Crash the application due to message loss */
        abort();
   }


   // Call Middleware interface
   extern void vm_pusservices_newtm
     (void *, size_t);

   vm_pusservices_newtm
     ((void *)&IN_buf_tmpacket, (size_t)size_IN_buf_tmpacket);


}

