/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt18ObcpId_Initialize(asn1SccPusSt18ObcpId* pVal)
{
    *pVal = (asn1SccPusSt18ObcpId) {
    {
        0x00
    }
};
}
#endif

 
flag asn1SccPusSt18ObcpId_IsConstraintValid(const asn1SccPusSt18ObcpId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (10 == (int)pus_ST18_SIZE_OBCP_ID);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt18ObcpId;

	return ret;
}

flag asn1SccPusSt18ObcpId_Encode(const asn1SccPusSt18ObcpId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusSt18ObcpId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)10) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt18ObcpId_Decode(asn1SccPusSt18ObcpId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)10) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435457;
	}

	return ret;
}

flag asn1SccPusSt18ObcpId_ACN_Encode(const asn1SccPusSt18ObcpId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusSt18ObcpId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)10) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt18ObcpId_ACN_Decode(asn1SccPusSt18ObcpId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)10) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435458;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_18_2_6_12_Data_Initialize(asn1SccPusTC_18_2_6_12_Data* pVal)
{
    *pVal = (asn1SccPusTC_18_2_6_12_Data) {
    .obcpId = {
        {
            0x00
        }
    }
};
}
#endif

 
flag asn1SccPusTC_18_2_6_12_Data_IsConstraintValid(const asn1SccPusTC_18_2_6_12_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt18ObcpId_IsConstraintValid(&pVal->obcpId, pErrCode);


	return ret;
}

flag asn1SccPusTC_18_2_6_12_Data_Encode(const asn1SccPusTC_18_2_6_12_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_18_2_6_12_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_18_2_6_12_Data_Decode(asn1SccPusTC_18_2_6_12_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode obcpId */
	ret = asn1SccPusSt18ObcpId_Decode(&pVal->obcpId, pBitStrm, pErrCode);
	


	return ret;
}

flag asn1SccPusTC_18_2_6_12_Data_ACN_Encode(const asn1SccPusTC_18_2_6_12_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_18_2_6_12_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_ACN_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_18_2_6_12_Data_ACN_Decode(asn1SccPusTC_18_2_6_12_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode obcpId */
    ret = asn1SccPusSt18ObcpId_ACN_Decode(&pVal->obcpId, pBitStrm, pErrCode);


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt18ObcpCode_Initialize(asn1SccPusSt18ObcpCode* pVal)
{
    *pVal = (asn1SccPusSt18ObcpCode) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccPusSt18ObcpCode_IsConstraintValid(const asn1SccPusSt18ObcpCode* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)pus_ST18_MAX_SIZE_OBCP_CODE);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt18ObcpCode;

	return ret;
}

flag asn1SccPusSt18ObcpCode_Encode(const asn1SccPusSt18ObcpCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusSt18ObcpCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 1000);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt18ObcpCode_Decode(asn1SccPusSt18ObcpCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 1000);
	*pErrCode = ret ? 0 : 268435459;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435460;
	}

	return ret;
}

flag asn1SccPusSt18ObcpCode_ACN_Encode(const asn1SccPusSt18ObcpCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusSt18ObcpCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 1000);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt18ObcpCode_ACN_Decode(asn1SccPusSt18ObcpCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 1000);
    *pErrCode = ret ? 0 : 268435461;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435462;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt18ObservabilityLevel_Initialize(asn1SccPusSt18ObservabilityLevel* pVal)
{
    *pVal = (asn1SccPusSt18ObservabilityLevel) asn1Sccnone;
}
#endif

 
flag asn1SccPusSt18ObservabilityLevel_IsConstraintValid(const asn1SccPusSt18ObservabilityLevel* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1Sccnone) || (*pVal == asn1Sccprocedure)) || (*pVal == asn1Sccstep)) || (*pVal == asn1Sccdetailed));
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt18ObservabilityLevel;

	return ret;
}

flag asn1SccPusSt18ObservabilityLevel_Encode(const asn1SccPusSt18ObservabilityLevel* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt18ObservabilityLevel_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccnone:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case asn1Sccprocedure:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case asn1Sccstep:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case asn1Sccdetailed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusSt18ObservabilityLevel_Decode(asn1SccPusSt18ObservabilityLevel* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	*pErrCode = ret ? 0 : 268435463;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccnone;
	            break;
	        case 1: 
	            *pVal = asn1Sccprocedure;
	            break;
	        case 2: 
	            *pVal = asn1Sccstep;
	            break;
	        case 3: 
	            *pVal = asn1Sccdetailed;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusSt18ObservabilityLevel_ACN_Encode(const asn1SccPusSt18ObservabilityLevel* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccPusSt18ObservabilityLevel_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccnone:
	            intVal = 0;
	            break;
	        case asn1Sccprocedure:
	            intVal = 1;
	            break;
	        case asn1Sccstep:
	            intVal = 2;
	            break;
	        case asn1Sccdetailed:
	            intVal = 3;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741827;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 3);
    }

	return ret;
}

flag asn1SccPusSt18ObservabilityLevel_ACN_Decode(asn1SccPusSt18ObservabilityLevel* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 3);
    *pErrCode = ret ? 0 : 268435464;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccnone;
                break;
            case 1:
                *pVal = asn1Sccprocedure;
                break;
            case 2:
                *pVal = asn1Sccstep;
                break;
            case 3:
                *pVal = asn1Sccdetailed;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741828;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_18_3_Data_Initialize(asn1SccPusTC_18_3_Data* pVal)
{
    *pVal = (asn1SccPusTC_18_3_Data) {
    .obcpId = {
        {
            0x00
        }
    },
    .observabilityLevel = asn1Sccnone
};
}
#endif

 
flag asn1SccPusTC_18_3_Data_IsConstraintValid(const asn1SccPusTC_18_3_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt18ObcpId_IsConstraintValid(&pVal->obcpId, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt18ObservabilityLevel_IsConstraintValid(&pVal->observabilityLevel, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTC_18_3_Data_Encode(const asn1SccPusTC_18_3_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_18_3_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode observabilityLevel */
	        ret = asn1SccPusSt18ObservabilityLevel_Encode(&pVal->observabilityLevel, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTC_18_3_Data_Decode(asn1SccPusTC_18_3_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode obcpId */
	ret = asn1SccPusSt18ObcpId_Decode(&pVal->obcpId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode observabilityLevel */
	    ret = asn1SccPusSt18ObservabilityLevel_Decode(&pVal->observabilityLevel, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTC_18_3_Data_ACN_Encode(const asn1SccPusTC_18_3_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_18_3_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_ACN_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode observabilityLevel */
	        ret = asn1SccPusSt18ObservabilityLevel_ACN_Encode(&pVal->observabilityLevel, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTC_18_3_Data_ACN_Decode(asn1SccPusTC_18_3_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode obcpId */
    ret = asn1SccPusSt18ObcpId_ACN_Decode(&pVal->obcpId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode observabilityLevel */
        ret = asn1SccPusSt18ObservabilityLevel_ACN_Decode(&pVal->observabilityLevel, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketVersion_Initialize(asn1SccPusPacketVersion* pVal)
{
    *pVal = (asn1SccPusPacketVersion) asn1Sccpus_CCSDS_V1;
}
#endif

 
flag asn1SccPusPacketVersion_IsConstraintValid(const asn1SccPusPacketVersion* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal == asn1Sccpus_CCSDS_V1);
	*pErrCode = ret ? 0 : ERR_asn1SccPusPacketVersion;

	return ret;
}

flag asn1SccPusPacketVersion_Encode(const asn1SccPusPacketVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccpus_CCSDS_V1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
	        	break;
	        default:
	    	    *pErrCode = 1073741829; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusPacketVersion_Decode(asn1SccPusPacketVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
	*pErrCode = ret ? 0 : 268435465;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccpus_CCSDS_V1;
	            break;
	        default:
		        *pErrCode = 1073741830;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusPacketVersion_ACN_Encode(const asn1SccPusPacketVersion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccPusPacketVersion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccpus_CCSDS_V1:
	            intVal = 0;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741831;      //COVERAGE_IGNORE
	    }
	    /* No need to encode value since it will always be 0 */
    }

	return ret;
}

flag asn1SccPusPacketVersion_ACN_Decode(asn1SccPusPacketVersion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    intVal=0; ret = TRUE; *pErrCode = 0;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccpus_CCSDS_V1;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741832;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketType_Initialize(asn1SccPusPacketType* pVal)
{
    *pVal = (asn1SccPusPacketType) asn1Sccpus_TM;
}
#endif

 
flag asn1SccPusPacketType_IsConstraintValid(const asn1SccPusPacketType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccpus_TM) || (*pVal == asn1Sccpus_TC));
	*pErrCode = ret ? 0 : ERR_asn1SccPusPacketType;

	return ret;
}

flag asn1SccPusPacketType_Encode(const asn1SccPusPacketType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccpus_TM:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccpus_TC:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1073741833; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusPacketType_Decode(asn1SccPusPacketType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435466;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccpus_TM;
	            break;
	        case 1: 
	            *pVal = asn1Sccpus_TC;
	            break;
	        default:
		        *pErrCode = 1073741834;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusPacketType_ACN_Encode(const asn1SccPusPacketType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccPusPacketType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccpus_TM:
	            intVal = 0;
	            break;
	        case asn1Sccpus_TC:
	            intVal = 1;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741835;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
    }

	return ret;
}

flag asn1SccPusPacketType_ACN_Decode(asn1SccPusPacketType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 1);
    *pErrCode = ret ? 0 : 268435467;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccpus_TM;
                break;
            case 1:
                *pVal = asn1Sccpus_TC;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741836;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSecondaryHeaderFlag_Initialize(asn1SccPusSecondaryHeaderFlag* pVal)
{
    *pVal = (asn1SccPusSecondaryHeaderFlag) FALSE;
}
#endif

 
flag asn1SccPusSecondaryHeaderFlag_IsConstraintValid(const asn1SccPusSecondaryHeaderFlag* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag asn1SccPusSecondaryHeaderFlag_Encode(const asn1SccPusSecondaryHeaderFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSecondaryHeaderFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag asn1SccPusSecondaryHeaderFlag_Decode(asn1SccPusSecondaryHeaderFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435468;

	return ret;
}

flag asn1SccPusSecondaryHeaderFlag_ACN_Encode(const asn1SccPusSecondaryHeaderFlag* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSecondaryHeaderFlag_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag asn1SccPusSecondaryHeaderFlag_ACN_Decode(asn1SccPusSecondaryHeaderFlag* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435469;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSequenceFlags_Initialize(asn1SccPusSequenceFlags* pVal)
{
    *pVal = (asn1SccPusSequenceFlags) asn1Sccpus_STANDALONE_PACKET;
}
#endif

 
flag asn1SccPusSequenceFlags_IsConstraintValid(const asn1SccPusSequenceFlags* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal == asn1Sccpus_STANDALONE_PACKET);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSequenceFlags;

	return ret;
}

flag asn1SccPusSequenceFlags_Encode(const asn1SccPusSequenceFlags* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSequenceFlags_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccpus_STANDALONE_PACKET:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 0);
	        	break;
	        default:
	    	    *pErrCode = 1073741837; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusSequenceFlags_Decode(asn1SccPusSequenceFlags* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 0);
	*pErrCode = ret ? 0 : 268435470;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccpus_STANDALONE_PACKET;
	            break;
	        default:
		        *pErrCode = 1073741838;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusSequenceFlags_ACN_Encode(const asn1SccPusSequenceFlags* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccPusSequenceFlags_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccpus_STANDALONE_PACKET:
	            intVal = 0;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741839;      //COVERAGE_IGNORE
	    }
	    /* No need to encode value since it will always be 0 */
    }

	return ret;
}

flag asn1SccPusSequenceFlags_ACN_Decode(asn1SccPusSequenceFlags* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    intVal=0; ret = TRUE; *pErrCode = 0;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccpus_STANDALONE_PACKET;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741840;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusVersionNumber_Initialize(asn1SccPusVersionNumber* pVal)
{
    *pVal = (asn1SccPusVersionNumber) asn1Sccpus_V0;
}
#endif

 
flag asn1SccPusVersionNumber_IsConstraintValid(const asn1SccPusVersionNumber* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1Sccpus_V0) || (*pVal == asn1Sccpus_V1)) || (*pVal == asn1Sccpus_V2)) || (*pVal == asn1Sccpus_INVALID_VERSION));
	*pErrCode = ret ? 0 : ERR_asn1SccPusVersionNumber;

	return ret;
}

flag asn1SccPusVersionNumber_Encode(const asn1SccPusVersionNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusVersionNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccpus_V0:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case asn1Sccpus_V1:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case asn1Sccpus_V2:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case asn1Sccpus_INVALID_VERSION:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = 1073741841; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusVersionNumber_Decode(asn1SccPusVersionNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	*pErrCode = ret ? 0 : 268435471;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccpus_V0;
	            break;
	        case 1: 
	            *pVal = asn1Sccpus_V1;
	            break;
	        case 2: 
	            *pVal = asn1Sccpus_V2;
	            break;
	        case 3: 
	            *pVal = asn1Sccpus_INVALID_VERSION;
	            break;
	        default:
		        *pErrCode = 1073741842;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusVersionNumber_ACN_Encode(const asn1SccPusVersionNumber* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? asn1SccPusVersionNumber_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case asn1Sccpus_V0:
	            intVal = 0;
	            break;
	        case asn1Sccpus_V1:
	            intVal = 1;
	            break;
	        case asn1Sccpus_V2:
	            intVal = 2;
	            break;
	        case asn1Sccpus_INVALID_VERSION:
	            intVal = 3;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741843;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 3);
    }

	return ret;
}

flag asn1SccPusVersionNumber_ACN_Decode(asn1SccPusVersionNumber* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 3);
    *pErrCode = ret ? 0 : 268435472;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = asn1Sccpus_V0;
                break;
            case 1:
                *pVal = asn1Sccpus_V1;
                break;
            case 2:
                *pVal = asn1Sccpus_V2;
                break;
            case 3:
                *pVal = asn1Sccpus_INVALID_VERSION;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741844;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusAcknowledgementFlags_Initialize(asn1SccPusAcknowledgementFlags* pVal)
{
    *pVal = (asn1SccPusAcknowledgementFlags) {
    .acceptanceReportRequested = FALSE,
    .startReportRequested = FALSE,
    .progressReportRequested = FALSE,
    .completionReportRequested = FALSE
};
}
#endif

 
flag asn1SccPusAcknowledgementFlags_IsConstraintValid(const asn1SccPusAcknowledgementFlags* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    ret = TRUE; *pErrCode = 0;
	    if (ret) {
	        ret = TRUE; *pErrCode = 0;
	        if (ret) {
	            ret = TRUE; *pErrCode = 0;
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccPusAcknowledgementFlags_Encode(const asn1SccPusAcknowledgementFlags* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusAcknowledgementFlags_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode acceptanceReportRequested */
	    BitStream_AppendBit(pBitStrm,pVal->acceptanceReportRequested);
	    if (ret) {
	        /*Encode startReportRequested */
	        BitStream_AppendBit(pBitStrm,pVal->startReportRequested);
	        if (ret) {
	            /*Encode progressReportRequested */
	            BitStream_AppendBit(pBitStrm,pVal->progressReportRequested);
	            if (ret) {
	                /*Encode completionReportRequested */
	                BitStream_AppendBit(pBitStrm,pVal->completionReportRequested);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusAcknowledgementFlags_Decode(asn1SccPusAcknowledgementFlags* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode acceptanceReportRequested */
	ret = BitStream_ReadBit(pBitStrm, &pVal->acceptanceReportRequested);
	*pErrCode = ret ? 0 : 268435473;
	if (ret) {
	    /*Decode startReportRequested */
	    ret = BitStream_ReadBit(pBitStrm, &pVal->startReportRequested);
	    *pErrCode = ret ? 0 : 268435474;
	    if (ret) {
	        /*Decode progressReportRequested */
	        ret = BitStream_ReadBit(pBitStrm, &pVal->progressReportRequested);
	        *pErrCode = ret ? 0 : 268435475;
	        if (ret) {
	            /*Decode completionReportRequested */
	            ret = BitStream_ReadBit(pBitStrm, &pVal->completionReportRequested);
	            *pErrCode = ret ? 0 : 268435476;
	        
	        }
	    }
	}


	return ret;
}

flag asn1SccPusAcknowledgementFlags_ACN_Encode(const asn1SccPusAcknowledgementFlags* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusAcknowledgementFlags_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode acceptanceReportRequested */
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = pVal->acceptanceReportRequested ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
	    if (ret) {
	        /*Encode startReportRequested */
	        {
	        	static byte true_data[] = {0x80};
	        	static byte false_data[] = {0x7F};
	            byte* tmp = pVal->startReportRequested ? true_data : false_data; 
	            BitStream_AppendBits(pBitStrm, tmp, 1);
	        }
	        if (ret) {
	            /*Encode progressReportRequested */
	            {
	            	static byte true_data[] = {0x80};
	            	static byte false_data[] = {0x7F};
	                byte* tmp = pVal->progressReportRequested ? true_data : false_data; 
	                BitStream_AppendBits(pBitStrm, tmp, 1);
	            }
	            if (ret) {
	                /*Encode completionReportRequested */
	                {
	                	static byte true_data[] = {0x80};
	                	static byte false_data[] = {0x7F};
	                    byte* tmp = pVal->completionReportRequested ? true_data : false_data; 
	                    BitStream_AppendBits(pBitStrm, tmp, 1);
	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusAcknowledgementFlags_ACN_Decode(asn1SccPusAcknowledgementFlags* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode acceptanceReportRequested */
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->acceptanceReportRequested);
        *pErrCode = ret ? 0 : 268435477;
    }
    if (ret) {
        /*Decode startReportRequested */
        {
        	static byte tmp[] = {0x80};
        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->startReportRequested);
            *pErrCode = ret ? 0 : 268435478;
        }
        if (ret) {
            /*Decode progressReportRequested */
            {
            	static byte tmp[] = {0x80};
            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->progressReportRequested);
                *pErrCode = ret ? 0 : 268435479;
            }
            if (ret) {
                /*Decode completionReportRequested */
                {
                	static byte tmp[] = {0x80};
                	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->completionReportRequested);
                    *pErrCode = ret ? 0 : 268435480;
                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
    *pVal = (asn1SccT_Int32) -2147483648LL;
}
#endif

 
flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int32;

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : 268435481;

	return ret;
}

flag asn1SccT_Int32_ACN_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag asn1SccT_Int32_ACN_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
    *pErrCode = ret ? 0 : 268435482;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
    *pVal = (asn1SccT_UInt32) 0;
}
#endif

 
flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt32;

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435483;

	return ret;
}

flag asn1SccT_UInt32_ACN_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag asn1SccT_UInt32_ACN_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
    *pErrCode = ret ? 0 : 268435484;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
    *pVal = (asn1SccT_Int8) -128;
}
#endif

 
flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-128 <= *pVal && *pVal <= 127);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int8;

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -128, 127);
    }

	return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : 268435485;

	return ret;
}

flag asn1SccT_Int8_ACN_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -128, 127);
    }

	return ret;
}

flag asn1SccT_Int8_ACN_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
    *pErrCode = ret ? 0 : 268435486;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
    *pVal = (asn1SccT_UInt8) 0;
}
#endif

 
flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt8;

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : 268435487;

	return ret;
}

flag asn1SccT_UInt8_ACN_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag asn1SccT_UInt8_ACN_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : 268435488;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
    *pVal = (asn1SccT_Boolean) FALSE;
}
#endif

 
flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435489;

	return ret;
}

flag asn1SccT_Boolean_ACN_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag asn1SccT_Boolean_ACN_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435490;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt23RepositoryPath_Initialize(asn1SccPusSt23RepositoryPath* pVal)
{
    *pVal = (asn1SccPusSt23RepositoryPath) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccPusSt23RepositoryPath_IsConstraintValid(const asn1SccPusSt23RepositoryPath* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)pus_ST23_MAX_SIZE_REPOSITORY_PATH);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt23RepositoryPath;

	return ret;
}

flag asn1SccPusSt23RepositoryPath_Encode(const asn1SccPusSt23RepositoryPath* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusSt23RepositoryPath_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt23RepositoryPath_Decode(asn1SccPusSt23RepositoryPath* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30);
	*pErrCode = ret ? 0 : 268435491;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435492;
	}

	return ret;
}

flag asn1SccPusSt23RepositoryPath_ACN_Encode(const asn1SccPusSt23RepositoryPath* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusSt23RepositoryPath_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt23RepositoryPath_ACN_Decode(asn1SccPusSt23RepositoryPath* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30);
    *pErrCode = ret ? 0 : 268435493;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435494;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt23FileName_Initialize(asn1SccPusSt23FileName* pVal)
{
    *pVal = (asn1SccPusSt23FileName) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccPusSt23FileName_IsConstraintValid(const asn1SccPusSt23FileName* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)pus_ST23_MAX_SIZE_FILE_PATH);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt23FileName;

	return ret;
}

flag asn1SccPusSt23FileName_Encode(const asn1SccPusSt23FileName* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusSt23FileName_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt23FileName_Decode(asn1SccPusSt23FileName* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30);
	*pErrCode = ret ? 0 : 268435495;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435496;
	}

	return ret;
}

flag asn1SccPusSt23FileName_ACN_Encode(const asn1SccPusSt23FileName* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusSt23FileName_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt23FileName_ACN_Decode(asn1SccPusSt23FileName* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30);
    *pErrCode = ret ? 0 : 268435497;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435498;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_18_13_Data_Initialize(asn1SccPusTC_18_13_Data* pVal)
{
    *pVal = (asn1SccPusTC_18_13_Data) {
    .obcpId = {
        {
            0x00
        }
    },
    .repository = {1,
        {
            0x00
        }
    },
    .fileName = {1,
        {
            0x00
        }
    }
};
}
#endif

 
flag asn1SccPusTC_18_13_Data_IsConstraintValid(const asn1SccPusTC_18_13_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt18ObcpId_IsConstraintValid(&pVal->obcpId, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt23RepositoryPath_IsConstraintValid(&pVal->repository, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSt23FileName_IsConstraintValid(&pVal->fileName, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccPusTC_18_13_Data_Encode(const asn1SccPusTC_18_13_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_18_13_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode repository */
	        ret = asn1SccPusSt23RepositoryPath_Encode(&pVal->repository, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode fileName */
	            ret = asn1SccPusSt23FileName_Encode(&pVal->fileName, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTC_18_13_Data_Decode(asn1SccPusTC_18_13_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode obcpId */
	ret = asn1SccPusSt18ObcpId_Decode(&pVal->obcpId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode repository */
	    ret = asn1SccPusSt23RepositoryPath_Decode(&pVal->repository, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode fileName */
	        ret = asn1SccPusSt23FileName_Decode(&pVal->fileName, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag asn1SccPusTC_18_13_Data_ACN_Encode(const asn1SccPusTC_18_13_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_18_13_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_ACN_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode repository */
	        ret = asn1SccPusSt23RepositoryPath_ACN_Encode(&pVal->repository, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode fileName */
	            ret = asn1SccPusSt23FileName_ACN_Encode(&pVal->fileName, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTC_18_13_Data_ACN_Decode(asn1SccPusTC_18_13_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode obcpId */
    ret = asn1SccPusSt18ObcpId_ACN_Decode(&pVal->obcpId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode repository */
        ret = asn1SccPusSt23RepositoryPath_ACN_Decode(&pVal->repository, pBitStrm, pErrCode);
        if (ret) {
            /*Decode fileName */
            ret = asn1SccPusSt23FileName_ACN_Decode(&pVal->fileName, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_23_2_3_Data_Initialize(asn1SccPusTC_23_2_3_Data* pVal)
{
    *pVal = (asn1SccPusTC_23_2_3_Data) {
    .repository = {1,
        {
            0x00
        }
    },
    .fileName = {1,
        {
            0x00
        }
    }
};
}
#endif

 
flag asn1SccPusTC_23_2_3_Data_IsConstraintValid(const asn1SccPusTC_23_2_3_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt23RepositoryPath_IsConstraintValid(&pVal->repository, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt23FileName_IsConstraintValid(&pVal->fileName, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTC_23_2_3_Data_Encode(const asn1SccPusTC_23_2_3_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_23_2_3_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode repository */
	    ret = asn1SccPusSt23RepositoryPath_Encode(&pVal->repository, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode fileName */
	        ret = asn1SccPusSt23FileName_Encode(&pVal->fileName, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTC_23_2_3_Data_Decode(asn1SccPusTC_23_2_3_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode repository */
	ret = asn1SccPusSt23RepositoryPath_Decode(&pVal->repository, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode fileName */
	    ret = asn1SccPusSt23FileName_Decode(&pVal->fileName, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTC_23_2_3_Data_ACN_Encode(const asn1SccPusTC_23_2_3_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_23_2_3_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode repository */
	    ret = asn1SccPusSt23RepositoryPath_ACN_Encode(&pVal->repository, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode fileName */
	        ret = asn1SccPusSt23FileName_ACN_Encode(&pVal->fileName, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTC_23_2_3_Data_ACN_Decode(asn1SccPusTC_23_2_3_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode repository */
    ret = asn1SccPusSt23RepositoryPath_ACN_Decode(&pVal->repository, pBitStrm, pErrCode);
    if (ret) {
        /*Decode fileName */
        ret = asn1SccPusSt23FileName_ACN_Decode(&pVal->fileName, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_23_14_Data_Initialize(asn1SccPusTC_23_14_Data* pVal)
{
    *pVal = (asn1SccPusTC_23_14_Data) {
    .sourceRepository = {1,
        {
            0x00
        }
    },
    .sourceFileName = {1,
        {
            0x00
        }
    },
    .targetRepository = {1,
        {
            0x00
        }
    },
    .targetFileName = {1,
        {
            0x00
        }
    }
};
}
#endif

 
flag asn1SccPusTC_23_14_Data_IsConstraintValid(const asn1SccPusTC_23_14_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt23RepositoryPath_IsConstraintValid(&pVal->sourceRepository, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt23FileName_IsConstraintValid(&pVal->sourceFileName, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSt23RepositoryPath_IsConstraintValid(&pVal->targetRepository, pErrCode);
	        if (ret) {
	            ret = asn1SccPusSt23FileName_IsConstraintValid(&pVal->targetFileName, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccPusTC_23_14_Data_Encode(const asn1SccPusTC_23_14_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_23_14_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceRepository */
	    ret = asn1SccPusSt23RepositoryPath_Encode(&pVal->sourceRepository, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceFileName */
	        ret = asn1SccPusSt23FileName_Encode(&pVal->sourceFileName, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetRepository */
	            ret = asn1SccPusSt23RepositoryPath_Encode(&pVal->targetRepository, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode targetFileName */
	                ret = asn1SccPusSt23FileName_Encode(&pVal->targetFileName, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTC_23_14_Data_Decode(asn1SccPusTC_23_14_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceRepository */
	ret = asn1SccPusSt23RepositoryPath_Decode(&pVal->sourceRepository, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceFileName */
	    ret = asn1SccPusSt23FileName_Decode(&pVal->sourceFileName, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetRepository */
	        ret = asn1SccPusSt23RepositoryPath_Decode(&pVal->targetRepository, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode targetFileName */
	            ret = asn1SccPusSt23FileName_Decode(&pVal->targetFileName, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

flag asn1SccPusTC_23_14_Data_ACN_Encode(const asn1SccPusTC_23_14_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_23_14_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceRepository */
	    ret = asn1SccPusSt23RepositoryPath_ACN_Encode(&pVal->sourceRepository, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceFileName */
	        ret = asn1SccPusSt23FileName_ACN_Encode(&pVal->sourceFileName, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetRepository */
	            ret = asn1SccPusSt23RepositoryPath_ACN_Encode(&pVal->targetRepository, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode targetFileName */
	                ret = asn1SccPusSt23FileName_ACN_Encode(&pVal->targetFileName, pBitStrm, pErrCode, FALSE);

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTC_23_14_Data_ACN_Decode(asn1SccPusTC_23_14_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode sourceRepository */
    ret = asn1SccPusSt23RepositoryPath_ACN_Decode(&pVal->sourceRepository, pBitStrm, pErrCode);
    if (ret) {
        /*Decode sourceFileName */
        ret = asn1SccPusSt23FileName_ACN_Decode(&pVal->sourceFileName, pBitStrm, pErrCode);
        if (ret) {
            /*Decode targetRepository */
            ret = asn1SccPusSt23RepositoryPath_ACN_Decode(&pVal->targetRepository, pBitStrm, pErrCode);
            if (ret) {
                /*Decode targetFileName */
                ret = asn1SccPusSt23FileName_ACN_Decode(&pVal->targetFileName, pBitStrm, pErrCode);

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt23RepositoryDomain_Initialize(asn1SccPusSt23RepositoryDomain* pVal)
{
    *pVal = (asn1SccPusSt23RepositoryDomain) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccPusSt23RepositoryDomain_IsConstraintValid(const asn1SccPusSt23RepositoryDomain* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)pus_ST23_MAX_SIZE_REPOSITORY_DOMAIN);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt23RepositoryDomain;

	return ret;
}

flag asn1SccPusSt23RepositoryDomain_Encode(const asn1SccPusSt23RepositoryDomain* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusSt23RepositoryDomain_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt23RepositoryDomain_Decode(asn1SccPusSt23RepositoryDomain* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30);
	*pErrCode = ret ? 0 : 268435499;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435500;
	}

	return ret;
}

flag asn1SccPusSt23RepositoryDomain_ACN_Encode(const asn1SccPusSt23RepositoryDomain* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusSt23RepositoryDomain_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 30);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccPusSt23RepositoryDomain_ACN_Decode(asn1SccPusSt23RepositoryDomain* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 30);
    *pErrCode = ret ? 0 : 268435501;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435502;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt3_Initialize(asn1SccPusUInt3* pVal)
{
    *pVal = (asn1SccPusUInt3) 0;
}
#endif

 
flag asn1SccPusUInt3_IsConstraintValid(const asn1SccPusUInt3* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 7);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt3;

	return ret;
}

flag asn1SccPusUInt3_Encode(const asn1SccPusUInt3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt3_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 7);
    }

	return ret;
}

flag asn1SccPusUInt3_Decode(asn1SccPusUInt3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
	*pErrCode = ret ? 0 : 268435503;

	return ret;
}

flag asn1SccPusUInt3_ACN_Encode(const asn1SccPusUInt3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt3_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 7);
    }

	return ret;
}

flag asn1SccPusUInt3_ACN_Decode(asn1SccPusUInt3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 7);
    *pErrCode = ret ? 0 : 268435504;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt4_Initialize(asn1SccPusUInt4* pVal)
{
    *pVal = (asn1SccPusUInt4) 0;
}
#endif

 
flag asn1SccPusUInt4_IsConstraintValid(const asn1SccPusUInt4* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 5);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt4;

	return ret;
}

flag asn1SccPusUInt4_Encode(const asn1SccPusUInt4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt4_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 5);
    }

	return ret;
}

flag asn1SccPusUInt4_Decode(asn1SccPusUInt4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 5);
	*pErrCode = ret ? 0 : 268435505;

	return ret;
}

flag asn1SccPusUInt4_ACN_Encode(const asn1SccPusUInt4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt4_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 5);
    }

	return ret;
}

flag asn1SccPusUInt4_ACN_Decode(asn1SccPusUInt4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 5);
    *pErrCode = ret ? 0 : 268435506;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTimeReferenceStatus_Initialize(asn1SccPusTimeReferenceStatus* pVal)
{
    *pVal = (asn1SccPusTimeReferenceStatus) 0;
}
#endif

 
flag asn1SccPusTimeReferenceStatus_IsConstraintValid(const asn1SccPusTimeReferenceStatus* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt4_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusTimeReferenceStatus_Encode(const asn1SccPusTimeReferenceStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTimeReferenceStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt4_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusTimeReferenceStatus_Decode(asn1SccPusTimeReferenceStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt4_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusTimeReferenceStatus_ACN_Encode(const asn1SccPusTimeReferenceStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTimeReferenceStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt4_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusTimeReferenceStatus_ACN_Decode(asn1SccPusTimeReferenceStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt4_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt8_Initialize(asn1SccPusUInt8* pVal)
{
    *pVal = (asn1SccPusUInt8) 0;
}
#endif

 
flag asn1SccPusUInt8_IsConstraintValid(const asn1SccPusUInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt8;

	return ret;
}

flag asn1SccPusUInt8_Encode(const asn1SccPusUInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag asn1SccPusUInt8_Decode(asn1SccPusUInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : 268435507;

	return ret;
}

flag asn1SccPusUInt8_ACN_Encode(const asn1SccPusUInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag asn1SccPusUInt8_ACN_Decode(asn1SccPusUInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : 268435508;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusServiceType_Initialize(asn1SccPusServiceType* pVal)
{
    *pVal = (asn1SccPusServiceType) 0;
}
#endif

 
flag asn1SccPusServiceType_IsConstraintValid(const asn1SccPusServiceType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt8_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusServiceType_Encode(const asn1SccPusServiceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusServiceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusServiceType_Decode(asn1SccPusServiceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt8_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusServiceType_ACN_Encode(const asn1SccPusServiceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusServiceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt8_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusServiceType_ACN_Decode(asn1SccPusServiceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt8_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSubserviceType_Initialize(asn1SccPusSubserviceType* pVal)
{
    *pVal = (asn1SccPusSubserviceType) 0;
}
#endif

 
flag asn1SccPusSubserviceType_IsConstraintValid(const asn1SccPusSubserviceType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt8_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSubserviceType_Encode(const asn1SccPusSubserviceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSubserviceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSubserviceType_Decode(asn1SccPusSubserviceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt8_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSubserviceType_ACN_Encode(const asn1SccPusSubserviceType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSubserviceType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt8_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSubserviceType_ACN_Decode(asn1SccPusSubserviceType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt8_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt11_Initialize(asn1SccPusUInt11* pVal)
{
    *pVal = (asn1SccPusUInt11) 0;
}
#endif

 
flag asn1SccPusUInt11_IsConstraintValid(const asn1SccPusUInt11* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 2047);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt11;

	return ret;
}

flag asn1SccPusUInt11_Encode(const asn1SccPusUInt11* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt11_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 2047);
    }

	return ret;
}

flag asn1SccPusUInt11_Decode(asn1SccPusUInt11* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 2047);
	*pErrCode = ret ? 0 : 268435509;

	return ret;
}

flag asn1SccPusUInt11_ACN_Encode(const asn1SccPusUInt11* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt11_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 2047);
    }

	return ret;
}

flag asn1SccPusUInt11_ACN_Decode(asn1SccPusUInt11* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 2047);
    *pErrCode = ret ? 0 : 268435510;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusApid_Initialize(asn1SccPusApid* pVal)
{
    *pVal = (asn1SccPusApid) 0;
}
#endif

 
flag asn1SccPusApid_IsConstraintValid(const asn1SccPusApid* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt11_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusApid_Encode(const asn1SccPusApid* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusApid_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt11_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusApid_Decode(asn1SccPusApid* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt11_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusApid_ACN_Encode(const asn1SccPusApid* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusApid_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt11_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusApid_ACN_Decode(asn1SccPusApid* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt11_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTcHeader_Initialize(asn1SccPusTcHeader* pVal)
{
    *pVal = (asn1SccPusTcHeader) {
    .pusVersion = asn1Sccpus_V0,
    .ackFlags = {
        .acceptanceReportRequested = FALSE,
        .startReportRequested = FALSE,
        .progressReportRequested = FALSE,
        .completionReportRequested = FALSE
    },
    .serviceId = 0,
    .subtype = 0,
    .source = 0
};
}
#endif

 
flag asn1SccPusTcHeader_IsConstraintValid(const asn1SccPusTcHeader* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusVersionNumber_IsConstraintValid(&pVal->pusVersion, pErrCode);
	if (ret) {
	    ret = asn1SccPusAcknowledgementFlags_IsConstraintValid(&pVal->ackFlags, pErrCode);
	    if (ret) {
	        ret = asn1SccPusServiceType_IsConstraintValid(&pVal->serviceId, pErrCode);
	        if (ret) {
	            ret = asn1SccPusSubserviceType_IsConstraintValid(&pVal->subtype, pErrCode);
	            if (ret) {
	                ret = asn1SccPusApid_IsConstraintValid(&pVal->source, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccPusTcHeader_Encode(const asn1SccPusTcHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTcHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pusVersion */
	    ret = asn1SccPusVersionNumber_Encode(&pVal->pusVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode ackFlags */
	        ret = asn1SccPusAcknowledgementFlags_Encode(&pVal->ackFlags, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode serviceId */
	            ret = asn1SccPusServiceType_Encode(&pVal->serviceId, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode subtype */
	                ret = asn1SccPusSubserviceType_Encode(&pVal->subtype, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode source */
	                    ret = asn1SccPusApid_Encode(&pVal->source, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTcHeader_Decode(asn1SccPusTcHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pusVersion */
	ret = asn1SccPusVersionNumber_Decode(&pVal->pusVersion, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode ackFlags */
	    ret = asn1SccPusAcknowledgementFlags_Decode(&pVal->ackFlags, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode serviceId */
	        ret = asn1SccPusServiceType_Decode(&pVal->serviceId, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode subtype */
	            ret = asn1SccPusSubserviceType_Decode(&pVal->subtype, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode source */
	                ret = asn1SccPusApid_Decode(&pVal->source, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}

flag asn1SccPusTcHeader_ACN_Encode(const asn1SccPusTcHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTcHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pusVersion */
	    ret = asn1SccPusVersionNumber_ACN_Encode(&pVal->pusVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode ackFlags */
	        ret = asn1SccPusAcknowledgementFlags_ACN_Encode(&pVal->ackFlags, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode serviceId */
	            ret = asn1SccPusServiceType_ACN_Encode(&pVal->serviceId, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode subtype */
	                ret = asn1SccPusSubserviceType_ACN_Encode(&pVal->subtype, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode source */
	                    ret = asn1SccPusApid_ACN_Encode(&pVal->source, pBitStrm, pErrCode, FALSE);

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTcHeader_ACN_Decode(asn1SccPusTcHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode pusVersion */
    ret = asn1SccPusVersionNumber_ACN_Decode(&pVal->pusVersion, pBitStrm, pErrCode);
    if (ret) {
        /*Decode ackFlags */
        ret = asn1SccPusAcknowledgementFlags_ACN_Decode(&pVal->ackFlags, pBitStrm, pErrCode);
        if (ret) {
            /*Decode serviceId */
            ret = asn1SccPusServiceType_ACN_Decode(&pVal->serviceId, pBitStrm, pErrCode);
            if (ret) {
                /*Decode subtype */
                ret = asn1SccPusSubserviceType_ACN_Decode(&pVal->subtype, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode source */
                    ret = asn1SccPusApid_ACN_Decode(&pVal->source, pBitStrm, pErrCode);

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt14_Initialize(asn1SccPusUInt14* pVal)
{
    *pVal = (asn1SccPusUInt14) 0;
}
#endif

 
flag asn1SccPusUInt14_IsConstraintValid(const asn1SccPusUInt14* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 16383);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt14;

	return ret;
}

flag asn1SccPusUInt14_Encode(const asn1SccPusUInt14* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt14_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 16383);
    }

	return ret;
}

flag asn1SccPusUInt14_Decode(asn1SccPusUInt14* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16383);
	*pErrCode = ret ? 0 : 268435511;

	return ret;
}

flag asn1SccPusUInt14_ACN_Encode(const asn1SccPusUInt14* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt14_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 16383);
    }

	return ret;
}

flag asn1SccPusUInt14_ACN_Decode(asn1SccPusUInt14* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16383);
    *pErrCode = ret ? 0 : 268435512;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSequenceCount_Initialize(asn1SccPusSequenceCount* pVal)
{
    *pVal = (asn1SccPusSequenceCount) 0;
}
#endif

 
flag asn1SccPusSequenceCount_IsConstraintValid(const asn1SccPusSequenceCount* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt14_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSequenceCount_Encode(const asn1SccPusSequenceCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSequenceCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt14_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSequenceCount_Decode(asn1SccPusSequenceCount* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt14_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSequenceCount_ACN_Encode(const asn1SccPusSequenceCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSequenceCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt14_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSequenceCount_ACN_Decode(asn1SccPusSequenceCount* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt14_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt01RequestId_Initialize(asn1SccPusSt01RequestId* pVal)
{
    *pVal = (asn1SccPusSt01RequestId) {
    .packetVersion = asn1Sccpus_CCSDS_V1,
    .packetType = asn1Sccpus_TM,
    .secondaryHeaderFlag = FALSE,
    .apid = 0,
    .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
    .sequenceCount = 0
};
}
#endif

 
flag asn1SccPusSt01RequestId_IsConstraintValid(const asn1SccPusSt01RequestId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusPacketVersion_IsConstraintValid(&pVal->packetVersion, pErrCode);
	if (ret) {
	    ret = asn1SccPusPacketType_IsConstraintValid(&pVal->packetType, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSecondaryHeaderFlag_IsConstraintValid(&pVal->secondaryHeaderFlag, pErrCode);
	        if (ret) {
	            ret = asn1SccPusApid_IsConstraintValid(&pVal->apid, pErrCode);
	            if (ret) {
	                ret = asn1SccPusSequenceFlags_IsConstraintValid(&pVal->sequenceFlags, pErrCode);
	                if (ret) {
	                    ret = asn1SccPusSequenceCount_IsConstraintValid(&pVal->sequenceCount, pErrCode);
	                
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccPusSt01RequestId_Encode(const asn1SccPusSt01RequestId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt01RequestId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetVersion */
	    ret = asn1SccPusPacketVersion_Encode(&pVal->packetVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetType */
	        ret = asn1SccPusPacketType_Encode(&pVal->packetType, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode secondaryHeaderFlag */
	            ret = asn1SccPusSecondaryHeaderFlag_Encode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode apid */
	                ret = asn1SccPusApid_Encode(&pVal->apid, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequenceFlags */
	                    ret = asn1SccPusSequenceFlags_Encode(&pVal->sequenceFlags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequenceCount */
	                        ret = asn1SccPusSequenceCount_Encode(&pVal->sequenceCount, pBitStrm, pErrCode, FALSE);
	                    
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusSt01RequestId_Decode(asn1SccPusSt01RequestId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode packetVersion */
	ret = asn1SccPusPacketVersion_Decode(&pVal->packetVersion, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode packetType */
	    ret = asn1SccPusPacketType_Decode(&pVal->packetType, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode secondaryHeaderFlag */
	        ret = asn1SccPusSecondaryHeaderFlag_Decode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode apid */
	            ret = asn1SccPusApid_Decode(&pVal->apid, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode sequenceFlags */
	                ret = asn1SccPusSequenceFlags_Decode(&pVal->sequenceFlags, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode sequenceCount */
	                    ret = asn1SccPusSequenceCount_Decode(&pVal->sequenceCount, pBitStrm, pErrCode);
	                
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag asn1SccPusSt01RequestId_ACN_Encode(const asn1SccPusSt01RequestId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt01RequestId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetVersion */
	    ret = asn1SccPusPacketVersion_ACN_Encode(&pVal->packetVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetType */
	        ret = asn1SccPusPacketType_ACN_Encode(&pVal->packetType, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode secondaryHeaderFlag */
	            ret = asn1SccPusSecondaryHeaderFlag_ACN_Encode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode apid */
	                ret = asn1SccPusApid_ACN_Encode(&pVal->apid, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequenceFlags */
	                    ret = asn1SccPusSequenceFlags_ACN_Encode(&pVal->sequenceFlags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequenceCount */
	                        ret = asn1SccPusSequenceCount_ACN_Encode(&pVal->sequenceCount, pBitStrm, pErrCode, FALSE);

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusSt01RequestId_ACN_Decode(asn1SccPusSt01RequestId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode packetVersion */
    ret = asn1SccPusPacketVersion_ACN_Decode(&pVal->packetVersion, pBitStrm, pErrCode);
    if (ret) {
        /*Decode packetType */
        ret = asn1SccPusPacketType_ACN_Decode(&pVal->packetType, pBitStrm, pErrCode);
        if (ret) {
            /*Decode secondaryHeaderFlag */
            ret = asn1SccPusSecondaryHeaderFlag_ACN_Decode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode);
            if (ret) {
                /*Decode apid */
                ret = asn1SccPusApid_ACN_Decode(&pVal->apid, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode sequenceFlags */
                    ret = asn1SccPusSequenceFlags_ACN_Decode(&pVal->sequenceFlags, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode sequenceCount */
                        ret = asn1SccPusSequenceCount_ACN_Decode(&pVal->sequenceCount, pBitStrm, pErrCode);

                    }

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt16_Initialize(asn1SccPusUInt16* pVal)
{
    *pVal = (asn1SccPusUInt16) 0;
}
#endif

 
flag asn1SccPusUInt16_IsConstraintValid(const asn1SccPusUInt16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 65535);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt16;

	return ret;
}

flag asn1SccPusUInt16_Encode(const asn1SccPusUInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 65535);
    }

	return ret;
}

flag asn1SccPusUInt16_Decode(asn1SccPusUInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : 268435513;

	return ret;
}

flag asn1SccPusUInt16_ACN_Encode(const asn1SccPusUInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 65535);
    }

	return ret;
}

flag asn1SccPusUInt16_ACN_Decode(asn1SccPusUInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
    *pErrCode = ret ? 0 : 268435514;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt18ObcpChecksum_Initialize(asn1SccPusSt18ObcpChecksum* pVal)
{
    *pVal = (asn1SccPusSt18ObcpChecksum) 0;
}
#endif

 
flag asn1SccPusSt18ObcpChecksum_IsConstraintValid(const asn1SccPusSt18ObcpChecksum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt16_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt18ObcpChecksum_Encode(const asn1SccPusSt18ObcpChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt18ObcpChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt18ObcpChecksum_Decode(asn1SccPusSt18ObcpChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt16_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt18ObcpChecksum_ACN_Encode(const asn1SccPusSt18ObcpChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt18ObcpChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt18ObcpChecksum_ACN_Decode(asn1SccPusSt18ObcpChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt16_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_18_1_Data_Initialize(asn1SccPusTC_18_1_Data* pVal)
{
    *pVal = (asn1SccPusTC_18_1_Data) {
    .obcpId = {
        {
            0x00
        }
    },
    .obcpCode = {1,
        {
            0x00
        }
    },
    .checksum = 0
};
}
#endif

 
flag asn1SccPusTC_18_1_Data_IsConstraintValid(const asn1SccPusTC_18_1_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt18ObcpId_IsConstraintValid(&pVal->obcpId, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt18ObcpCode_IsConstraintValid(&pVal->obcpCode, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSt18ObcpChecksum_IsConstraintValid(&pVal->checksum, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccPusTC_18_1_Data_Encode(const asn1SccPusTC_18_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_18_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode obcpCode */
	        ret = asn1SccPusSt18ObcpCode_Encode(&pVal->obcpCode, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode checksum */
	            ret = asn1SccPusSt18ObcpChecksum_Encode(&pVal->checksum, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTC_18_1_Data_Decode(asn1SccPusTC_18_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode obcpId */
	ret = asn1SccPusSt18ObcpId_Decode(&pVal->obcpId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode obcpCode */
	    ret = asn1SccPusSt18ObcpCode_Decode(&pVal->obcpCode, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode checksum */
	        ret = asn1SccPusSt18ObcpChecksum_Decode(&pVal->checksum, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag asn1SccPusTC_18_1_Data_ACN_Encode(const asn1SccPusTC_18_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_18_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_ACN_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode obcpCode */
	        ret = asn1SccPusSt18ObcpCode_ACN_Encode(&pVal->obcpCode, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode checksum */
	            ret = asn1SccPusSt18ObcpChecksum_ACN_Encode(&pVal->checksum, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTC_18_1_Data_ACN_Decode(asn1SccPusTC_18_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode obcpId */
    ret = asn1SccPusSt18ObcpId_ACN_Decode(&pVal->obcpId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode obcpCode */
        ret = asn1SccPusSt18ObcpCode_ACN_Decode(&pVal->obcpCode, pBitStrm, pErrCode);
        if (ret) {
            /*Decode checksum */
            ret = asn1SccPusSt18ObcpChecksum_ACN_Decode(&pVal->checksum, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketDataLength_Initialize(asn1SccPusPacketDataLength* pVal)
{
    *pVal = (asn1SccPusPacketDataLength) 0;
}
#endif

 
flag asn1SccPusPacketDataLength_IsConstraintValid(const asn1SccPusPacketDataLength* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt16_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusPacketDataLength_Encode(const asn1SccPusPacketDataLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketDataLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusPacketDataLength_Decode(asn1SccPusPacketDataLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt16_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusPacketDataLength_ACN_Encode(const asn1SccPusPacketDataLength* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacketDataLength_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusPacketDataLength_ACN_Decode(asn1SccPusPacketDataLength* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt16_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusMessageTypeCounter_Initialize(asn1SccPusMessageTypeCounter* pVal)
{
    *pVal = (asn1SccPusMessageTypeCounter) 0;
}
#endif

 
flag asn1SccPusMessageTypeCounter_IsConstraintValid(const asn1SccPusMessageTypeCounter* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt16_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusMessageTypeCounter_Encode(const asn1SccPusMessageTypeCounter* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusMessageTypeCounter_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusMessageTypeCounter_Decode(asn1SccPusMessageTypeCounter* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt16_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusMessageTypeCounter_ACN_Encode(const asn1SccPusMessageTypeCounter* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusMessageTypeCounter_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusMessageTypeCounter_ACN_Decode(asn1SccPusMessageTypeCounter* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt16_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusChecksum_Initialize(asn1SccPusChecksum* pVal)
{
    *pVal = (asn1SccPusChecksum) 0;
}
#endif

 
flag asn1SccPusChecksum_IsConstraintValid(const asn1SccPusChecksum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt16_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusChecksum_Encode(const asn1SccPusChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusChecksum_Decode(asn1SccPusChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt16_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusChecksum_ACN_Encode(const asn1SccPusChecksum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusChecksum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt16_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusChecksum_ACN_Decode(asn1SccPusChecksum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt16_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt32_Initialize(asn1SccPusUInt32* pVal)
{
    *pVal = (asn1SccPusUInt32) 0;
}
#endif

 
flag asn1SccPusUInt32_IsConstraintValid(const asn1SccPusUInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt32;

	return ret;
}

flag asn1SccPusUInt32_Encode(const asn1SccPusUInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag asn1SccPusUInt32_Decode(asn1SccPusUInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435515;

	return ret;
}

flag asn1SccPusUInt32_ACN_Encode(const asn1SccPusUInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag asn1SccPusUInt32_ACN_Decode(asn1SccPusUInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
    *pErrCode = ret ? 0 : 268435516;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt09ExponentialRate_Initialize(asn1SccPusSt09ExponentialRate* pVal)
{
    *pVal = (asn1SccPusSt09ExponentialRate) 0;
}
#endif

 
flag asn1SccPusSt09ExponentialRate_IsConstraintValid(const asn1SccPusSt09ExponentialRate* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt09ExponentialRate_Encode(const asn1SccPusSt09ExponentialRate* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt09ExponentialRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt09ExponentialRate_Decode(asn1SccPusSt09ExponentialRate* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt09ExponentialRate_ACN_Encode(const asn1SccPusSt09ExponentialRate* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt09ExponentialRate_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt09ExponentialRate_ACN_Decode(asn1SccPusSt09ExponentialRate* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_9_1_Data_Initialize(asn1SccPusTC_9_1_Data* pVal)
{
    *pVal = (asn1SccPusTC_9_1_Data) {
    .exponentialRate = 0
};
}
#endif

 
flag asn1SccPusTC_9_1_Data_IsConstraintValid(const asn1SccPusTC_9_1_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt09ExponentialRate_IsConstraintValid(&pVal->exponentialRate, pErrCode);


	return ret;
}

flag asn1SccPusTC_9_1_Data_Encode(const asn1SccPusTC_9_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_9_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode exponentialRate */
	    ret = asn1SccPusSt09ExponentialRate_Encode(&pVal->exponentialRate, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_9_1_Data_Decode(asn1SccPusTC_9_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode exponentialRate */
	ret = asn1SccPusSt09ExponentialRate_Decode(&pVal->exponentialRate, pBitStrm, pErrCode);
	


	return ret;
}

flag asn1SccPusTC_9_1_Data_ACN_Encode(const asn1SccPusTC_9_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_9_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode exponentialRate */
	    ret = asn1SccPusSt09ExponentialRate_ACN_Encode(&pVal->exponentialRate, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_9_1_Data_ACN_Decode(asn1SccPusTC_9_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode exponentialRate */
    ret = asn1SccPusSt09ExponentialRate_ACN_Decode(&pVal->exponentialRate, pBitStrm, pErrCode);


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_18_4_5_Data_Initialize(asn1SccPusTC_18_4_5_Data* pVal)
{
    *pVal = (asn1SccPusTC_18_4_5_Data) {
    .obcpId = {
        {
            0x00
        }
    },
    .stepId = 0
};
}
#endif

 
flag asn1SccPusTC_18_4_5_Data_IsConstraintValid(const asn1SccPusTC_18_4_5_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt18ObcpId_IsConstraintValid(&pVal->obcpId, pErrCode);
	if (ret) {
	    ret = asn1SccPusUInt32_IsConstraintValid(&pVal->stepId, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTC_18_4_5_Data_Encode(const asn1SccPusTC_18_4_5_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_18_4_5_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode stepId */
	        ret = asn1SccPusUInt32_Encode(&pVal->stepId, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTC_18_4_5_Data_Decode(asn1SccPusTC_18_4_5_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode obcpId */
	ret = asn1SccPusSt18ObcpId_Decode(&pVal->obcpId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode stepId */
	    ret = asn1SccPusUInt32_Decode(&pVal->stepId, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTC_18_4_5_Data_ACN_Encode(const asn1SccPusTC_18_4_5_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_18_4_5_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode obcpId */
	    ret = asn1SccPusSt18ObcpId_ACN_Encode(&pVal->obcpId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode stepId */
	        ret = asn1SccPusUInt32_ACN_Encode(&pVal->stepId, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTC_18_4_5_Data_ACN_Decode(asn1SccPusTC_18_4_5_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode obcpId */
    ret = asn1SccPusSt18ObcpId_ACN_Decode(&pVal->obcpId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode stepId */
        ret = asn1SccPusUInt32_ACN_Decode(&pVal->stepId, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt05EventId_Initialize(asn1SccPusSt05EventId* pVal)
{
    *pVal = (asn1SccPusSt05EventId) 0;
}
#endif

 
flag asn1SccPusSt05EventId_IsConstraintValid(const asn1SccPusSt05EventId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt05EventId_Encode(const asn1SccPusSt05EventId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt05EventId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt05EventId_Decode(asn1SccPusSt05EventId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt05EventId_ACN_Encode(const asn1SccPusSt05EventId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt05EventId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt05EventId_ACN_Decode(asn1SccPusSt05EventId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_19_X_Data_Initialize(asn1SccPusTC_19_X_Data* pVal)
{
    *pVal = (asn1SccPusTC_19_X_Data) {
    .eventId = 0
};
}
#endif

 
flag asn1SccPusTC_19_X_Data_IsConstraintValid(const asn1SccPusTC_19_X_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt05EventId_IsConstraintValid(&pVal->eventId, pErrCode);


	return ret;
}

flag asn1SccPusTC_19_X_Data_Encode(const asn1SccPusTC_19_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_19_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode eventId */
	    ret = asn1SccPusSt05EventId_Encode(&pVal->eventId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_19_X_Data_Decode(asn1SccPusTC_19_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode eventId */
	ret = asn1SccPusSt05EventId_Decode(&pVal->eventId, pBitStrm, pErrCode);
	


	return ret;
}

flag asn1SccPusTC_19_X_Data_ACN_Encode(const asn1SccPusTC_19_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_19_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode eventId */
	    ret = asn1SccPusSt05EventId_ACN_Encode(&pVal->eventId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_19_X_Data_ACN_Decode(asn1SccPusTC_19_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode eventId */
    ret = asn1SccPusSt05EventId_ACN_Decode(&pVal->eventId, pBitStrm, pErrCode);


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt03HousekeepingReportId_Initialize(asn1SccPusSt03HousekeepingReportId* pVal)
{
    *pVal = (asn1SccPusSt03HousekeepingReportId) 0;
}
#endif

 
flag asn1SccPusSt03HousekeepingReportId_IsConstraintValid(const asn1SccPusSt03HousekeepingReportId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt03HousekeepingReportId_Encode(const asn1SccPusSt03HousekeepingReportId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt03HousekeepingReportId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt03HousekeepingReportId_Decode(asn1SccPusSt03HousekeepingReportId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt03HousekeepingReportId_ACN_Encode(const asn1SccPusSt03HousekeepingReportId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt03HousekeepingReportId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt03HousekeepingReportId_ACN_Decode(asn1SccPusSt03HousekeepingReportId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt03ParameterId_Initialize(asn1SccPusSt03ParameterId* pVal)
{
    *pVal = (asn1SccPusSt03ParameterId) 0;
}
#endif

 
flag asn1SccPusSt03ParameterId_IsConstraintValid(const asn1SccPusSt03ParameterId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt03ParameterId_Encode(const asn1SccPusSt03ParameterId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt03ParameterId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt03ParameterId_Decode(asn1SccPusSt03ParameterId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt03ParameterId_ACN_Encode(const asn1SccPusSt03ParameterId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt03ParameterId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt03ParameterId_ACN_Decode(asn1SccPusSt03ParameterId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusStepId_Initialize(asn1SccPusStepId* pVal)
{
    *pVal = (asn1SccPusStepId) 0;
}
#endif

 
flag asn1SccPusStepId_IsConstraintValid(const asn1SccPusStepId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusStepId_Encode(const asn1SccPusStepId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusStepId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusStepId_Decode(asn1SccPusStepId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusStepId_ACN_Encode(const asn1SccPusStepId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusStepId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusStepId_ACN_Decode(asn1SccPusStepId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt12pmonId_Initialize(asn1SccPusSt12pmonId* pVal)
{
    *pVal = (asn1SccPusSt12pmonId) 0;
}
#endif

 
flag asn1SccPusSt12pmonId_IsConstraintValid(const asn1SccPusSt12pmonId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt12pmonId_Encode(const asn1SccPusSt12pmonId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt12pmonId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt12pmonId_Decode(asn1SccPusSt12pmonId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt12pmonId_ACN_Encode(const asn1SccPusSt12pmonId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt12pmonId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt12pmonId_ACN_Decode(asn1SccPusSt12pmonId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_12_1_2_Data_Initialize(asn1SccPusTC_12_1_2_Data* pVal)
{
    *pVal = (asn1SccPusTC_12_1_2_Data) {
    .pmonId = 0
};
}
#endif

 
flag asn1SccPusTC_12_1_2_Data_IsConstraintValid(const asn1SccPusTC_12_1_2_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt12pmonId_IsConstraintValid(&pVal->pmonId, pErrCode);


	return ret;
}

flag asn1SccPusTC_12_1_2_Data_Encode(const asn1SccPusTC_12_1_2_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_12_1_2_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pmonId */
	    ret = asn1SccPusSt12pmonId_Encode(&pVal->pmonId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_12_1_2_Data_Decode(asn1SccPusTC_12_1_2_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pmonId */
	ret = asn1SccPusSt12pmonId_Decode(&pVal->pmonId, pBitStrm, pErrCode);
	


	return ret;
}

flag asn1SccPusTC_12_1_2_Data_ACN_Encode(const asn1SccPusTC_12_1_2_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_12_1_2_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pmonId */
	    ret = asn1SccPusSt12pmonId_ACN_Encode(&pVal->pmonId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_12_1_2_Data_ACN_Decode(asn1SccPusTC_12_1_2_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode pmonId */
    ret = asn1SccPusSt12pmonId_ACN_Decode(&pVal->pmonId, pBitStrm, pErrCode);


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt01FailureCode_Initialize(asn1SccPusSt01FailureCode* pVal)
{
    *pVal = (asn1SccPusSt01FailureCode) 0;
}
#endif

 
flag asn1SccPusSt01FailureCode_IsConstraintValid(const asn1SccPusSt01FailureCode* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt01FailureCode_Encode(const asn1SccPusSt01FailureCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt01FailureCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt01FailureCode_Decode(asn1SccPusSt01FailureCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt01FailureCode_ACN_Encode(const asn1SccPusSt01FailureCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt01FailureCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt01FailureCode_ACN_Decode(asn1SccPusSt01FailureCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt08FunctionId_Initialize(asn1SccPusSt08FunctionId* pVal)
{
    *pVal = (asn1SccPusSt08FunctionId) 0;
}
#endif

 
flag asn1SccPusSt08FunctionId_IsConstraintValid(const asn1SccPusSt08FunctionId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt08FunctionId_Encode(const asn1SccPusSt08FunctionId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt08FunctionId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt08FunctionId_Decode(asn1SccPusSt08FunctionId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt08FunctionId_ACN_Encode(const asn1SccPusSt08FunctionId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt08FunctionId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt08FunctionId_ACN_Decode(asn1SccPusSt08FunctionId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_8_1_Data_Initialize(asn1SccPusTC_8_1_Data* pVal)
{
    *pVal = (asn1SccPusTC_8_1_Data) {
    .functionId = 0
};
}
#endif

 
flag asn1SccPusTC_8_1_Data_IsConstraintValid(const asn1SccPusTC_8_1_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt08FunctionId_IsConstraintValid(&pVal->functionId, pErrCode);


	return ret;
}

flag asn1SccPusTC_8_1_Data_Encode(const asn1SccPusTC_8_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_8_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode functionId */
	    ret = asn1SccPusSt08FunctionId_Encode(&pVal->functionId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_8_1_Data_Decode(asn1SccPusTC_8_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode functionId */
	ret = asn1SccPusSt08FunctionId_Decode(&pVal->functionId, pBitStrm, pErrCode);
	


	return ret;
}

flag asn1SccPusTC_8_1_Data_ACN_Encode(const asn1SccPusTC_8_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_8_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode functionId */
	    ret = asn1SccPusSt08FunctionId_ACN_Encode(&pVal->functionId, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccPusTC_8_1_Data_ACN_Decode(asn1SccPusTC_8_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode functionId */
    ret = asn1SccPusSt08FunctionId_ACN_Decode(&pVal->functionId, pBitStrm, pErrCode);


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt20OnBoardParameterId_Initialize(asn1SccPusSt20OnBoardParameterId* pVal)
{
    *pVal = (asn1SccPusSt20OnBoardParameterId) 0;
}
#endif

 
flag asn1SccPusSt20OnBoardParameterId_IsConstraintValid(const asn1SccPusSt20OnBoardParameterId* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt20OnBoardParameterId_Encode(const asn1SccPusSt20OnBoardParameterId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt20OnBoardParameterId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt20OnBoardParameterId_Decode(asn1SccPusSt20OnBoardParameterId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt20OnBoardParameterId_ACN_Encode(const asn1SccPusSt20OnBoardParameterId* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt20OnBoardParameterId_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt20OnBoardParameterId_ACN_Decode(asn1SccPusSt20OnBoardParameterId* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusConfigDummyType_Initialize(asn1SccPusConfigDummyType* pVal)
{
    *pVal = (asn1SccPusConfigDummyType) 0;
}
#endif

 
flag asn1SccPusConfigDummyType_IsConstraintValid(const asn1SccPusConfigDummyType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt32_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusConfigDummyType_Encode(const asn1SccPusConfigDummyType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusConfigDummyType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusConfigDummyType_Decode(asn1SccPusConfigDummyType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusConfigDummyType_ACN_Encode(const asn1SccPusConfigDummyType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusConfigDummyType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt32_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusConfigDummyType_ACN_Decode(asn1SccPusConfigDummyType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt32_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusUInt64_Initialize(asn1SccPusUInt64* pVal)
{
    *pVal = (asn1SccPusUInt64) 0;
}
#endif

 
flag asn1SccPusUInt64_IsConstraintValid(const asn1SccPusUInt64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccPusUInt64;

	return ret;
}

flag asn1SccPusUInt64_Encode(const asn1SccPusUInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusUInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 9223372036854775807LL);
    }

	return ret;
}

flag asn1SccPusUInt64_Decode(asn1SccPusUInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 9223372036854775807LL);
	*pErrCode = ret ? 0 : 268435517;

	return ret;
}

flag asn1SccPusUInt64_ACN_Encode(const asn1SccPusUInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusUInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 9223372036854775807LL);
    }

	return ret;
}

flag asn1SccPusUInt64_ACN_Decode(asn1SccPusUInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 9223372036854775807LL);
    *pErrCode = ret ? 0 : 268435518;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt05EventAuxData_Initialize(asn1SccPusSt05EventAuxData* pVal)
{
    *pVal = (asn1SccPusSt05EventAuxData) {
    .data1 = 0,
    .data2 = 0
};
}
#endif

 
flag asn1SccPusSt05EventAuxData_IsConstraintValid(const asn1SccPusSt05EventAuxData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt64_IsConstraintValid(&pVal->data1, pErrCode);
	if (ret) {
	    ret = asn1SccPusUInt64_IsConstraintValid(&pVal->data2, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusSt05EventAuxData_Encode(const asn1SccPusSt05EventAuxData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt05EventAuxData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data1 */
	    ret = asn1SccPusUInt64_Encode(&pVal->data1, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data2 */
	        ret = asn1SccPusUInt64_Encode(&pVal->data2, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusSt05EventAuxData_Decode(asn1SccPusSt05EventAuxData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data1 */
	ret = asn1SccPusUInt64_Decode(&pVal->data1, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data2 */
	    ret = asn1SccPusUInt64_Decode(&pVal->data2, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusSt05EventAuxData_ACN_Encode(const asn1SccPusSt05EventAuxData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt05EventAuxData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data1 */
	    ret = asn1SccPusUInt64_ACN_Encode(&pVal->data1, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data2 */
	        ret = asn1SccPusUInt64_ACN_Encode(&pVal->data2, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusSt05EventAuxData_ACN_Decode(asn1SccPusSt05EventAuxData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode data1 */
    ret = asn1SccPusUInt64_ACN_Decode(&pVal->data1, pBitStrm, pErrCode);
    if (ret) {
        /*Decode data2 */
        ret = asn1SccPusUInt64_ACN_Decode(&pVal->data2, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt05Event_Initialize(asn1SccPusSt05Event* pVal)
{
    *pVal = (asn1SccPusSt05Event) {
    .eventId = 0,
    .data = {
        .data1 = 0,
        .data2 = 0
    }
};
}
#endif

 
flag asn1SccPusSt05Event_IsConstraintValid(const asn1SccPusSt05Event* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt05EventId_IsConstraintValid(&pVal->eventId, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt05EventAuxData_IsConstraintValid(&pVal->data, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusSt05Event_Encode(const asn1SccPusSt05Event* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt05Event_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode eventId */
	    ret = asn1SccPusSt05EventId_Encode(&pVal->eventId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusSt05EventAuxData_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusSt05Event_Decode(asn1SccPusSt05Event* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode eventId */
	ret = asn1SccPusSt05EventId_Decode(&pVal->eventId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccPusSt05EventAuxData_Decode(&pVal->data, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusSt05Event_ACN_Encode(const asn1SccPusSt05Event* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt05Event_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode eventId */
	    ret = asn1SccPusSt05EventId_ACN_Encode(&pVal->eventId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusSt05EventAuxData_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusSt05Event_ACN_Decode(asn1SccPusSt05Event* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode eventId */
    ret = asn1SccPusSt05EventId_ACN_Decode(&pVal->eventId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode data */
        ret = asn1SccPusSt05EventAuxData_ACN_Decode(&pVal->data, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTM_5_X_Data_Initialize(asn1SccPusTM_5_X_Data* pVal)
{
    *pVal = (asn1SccPusTM_5_X_Data) {
    .eventId = 0,
    .data = {
        .data1 = 0,
        .data2 = 0
    }
};
}
#endif

 
flag asn1SccPusTM_5_X_Data_IsConstraintValid(const asn1SccPusTM_5_X_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt05Event_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusTM_5_X_Data_Encode(const asn1SccPusTM_5_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTM_5_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusSt05Event_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusTM_5_X_Data_Decode(asn1SccPusTM_5_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusSt05Event_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusTM_5_X_Data_ACN_Encode(const asn1SccPusTM_5_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTM_5_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusSt05Event_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusTM_5_X_Data_ACN_Decode(asn1SccPusTM_5_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusSt05Event_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt03StoredParam_Initialize(asn1SccPusSt03StoredParam* pVal)
{
    *pVal = (asn1SccPusSt03StoredParam) 0;
}
#endif

 
flag asn1SccPusSt03StoredParam_IsConstraintValid(const asn1SccPusSt03StoredParam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt64_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt03StoredParam_Encode(const asn1SccPusSt03StoredParam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt03StoredParam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt64_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt03StoredParam_Decode(asn1SccPusSt03StoredParam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt64_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt03StoredParam_ACN_Encode(const asn1SccPusSt03StoredParam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt03StoredParam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt64_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt03StoredParam_ACN_Decode(asn1SccPusSt03StoredParam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt64_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt03ParameterArray_Initialize(asn1SccPusSt03ParameterArray* pVal)
{
    *pVal = (asn1SccPusSt03ParameterArray) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccPusSt03ParameterArray_IsConstraintValid(const asn1SccPusSt03ParameterArray* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)pus_ST03_MAX_REPORT_LENGTH);
	*pErrCode = ret ? 0 : ERR_asn1SccPusSt03ParameterArray;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccPusSt03StoredParam_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccPusSt03ParameterArray_Encode(const asn1SccPusSt03ParameterArray* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusSt03ParameterArray_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 20);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccPusSt03StoredParam_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccPusSt03ParameterArray_Decode(asn1SccPusSt03ParameterArray* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 20);
	*pErrCode = ret ? 0 : 268435519;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccPusSt03StoredParam_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccPusSt03ParameterArray_ACN_Encode(const asn1SccPusSt03ParameterArray* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusSt03ParameterArray_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 20);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccPusSt03StoredParam_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccPusSt03ParameterArray_ACN_Decode(asn1SccPusSt03ParameterArray* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 20);
    *pErrCode = ret ? 0 : 268435520;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccPusSt03StoredParam_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTM_3_25_Data_Initialize(asn1SccPusTM_3_25_Data* pVal)
{
    *pVal = (asn1SccPusTM_3_25_Data) {
    .reportId = 0,
    .parameters = {    .nCount = 0,    .arr = 
        {
            
        }
    }
};
}
#endif

 
flag asn1SccPusTM_3_25_Data_IsConstraintValid(const asn1SccPusTM_3_25_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt03HousekeepingReportId_IsConstraintValid(&pVal->reportId, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt03ParameterArray_IsConstraintValid(&pVal->parameters, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTM_3_25_Data_Encode(const asn1SccPusTM_3_25_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTM_3_25_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode reportId */
	    ret = asn1SccPusSt03HousekeepingReportId_Encode(&pVal->reportId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode parameters */
	        ret = asn1SccPusSt03ParameterArray_Encode(&pVal->parameters, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTM_3_25_Data_Decode(asn1SccPusTM_3_25_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode reportId */
	ret = asn1SccPusSt03HousekeepingReportId_Decode(&pVal->reportId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode parameters */
	    ret = asn1SccPusSt03ParameterArray_Decode(&pVal->parameters, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTM_3_25_Data_ACN_Encode(const asn1SccPusTM_3_25_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTM_3_25_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode reportId */
	    ret = asn1SccPusSt03HousekeepingReportId_ACN_Encode(&pVal->reportId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode parameters */
	        ret = asn1SccPusSt03ParameterArray_ACN_Encode(&pVal->parameters, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTM_3_25_Data_ACN_Decode(asn1SccPusTM_3_25_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode reportId */
    ret = asn1SccPusSt03HousekeepingReportId_ACN_Decode(&pVal->reportId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode parameters */
        ret = asn1SccPusSt03ParameterArray_ACN_Decode(&pVal->parameters, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_TM_23_1_4_Data_Initialize(asn1SccPusTC_TM_23_1_4_Data* pVal)
{
    *pVal = (asn1SccPusTC_TM_23_1_4_Data) {
    .repository = {1,
        {
            0x00
        }
    },
    .fileName = {1,
        {
            0x00
        }
    },
    .maxSize = 0
};
}
#endif

 
flag asn1SccPusTC_TM_23_1_4_Data_IsConstraintValid(const asn1SccPusTC_TM_23_1_4_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt23RepositoryPath_IsConstraintValid(&pVal->repository, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt23FileName_IsConstraintValid(&pVal->fileName, pErrCode);
	    if (ret) {
	        ret = asn1SccPusUInt64_IsConstraintValid(&pVal->maxSize, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccPusTC_TM_23_1_4_Data_Encode(const asn1SccPusTC_TM_23_1_4_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_TM_23_1_4_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode repository */
	    ret = asn1SccPusSt23RepositoryPath_Encode(&pVal->repository, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode fileName */
	        ret = asn1SccPusSt23FileName_Encode(&pVal->fileName, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode maxSize */
	            ret = asn1SccPusUInt64_Encode(&pVal->maxSize, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTC_TM_23_1_4_Data_Decode(asn1SccPusTC_TM_23_1_4_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode repository */
	ret = asn1SccPusSt23RepositoryPath_Decode(&pVal->repository, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode fileName */
	    ret = asn1SccPusSt23FileName_Decode(&pVal->fileName, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode maxSize */
	        ret = asn1SccPusUInt64_Decode(&pVal->maxSize, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag asn1SccPusTC_TM_23_1_4_Data_ACN_Encode(const asn1SccPusTC_TM_23_1_4_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_TM_23_1_4_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode repository */
	    ret = asn1SccPusSt23RepositoryPath_ACN_Encode(&pVal->repository, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode fileName */
	        ret = asn1SccPusSt23FileName_ACN_Encode(&pVal->fileName, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode maxSize */
	            ret = asn1SccPusUInt64_ACN_Encode(&pVal->maxSize, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTC_TM_23_1_4_Data_ACN_Decode(asn1SccPusTC_TM_23_1_4_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode repository */
    ret = asn1SccPusSt23RepositoryPath_ACN_Decode(&pVal->repository, pBitStrm, pErrCode);
    if (ret) {
        /*Decode fileName */
        ret = asn1SccPusSt23FileName_ACN_Decode(&pVal->fileName, pBitStrm, pErrCode);
        if (ret) {
            /*Decode maxSize */
            ret = asn1SccPusUInt64_ACN_Decode(&pVal->maxSize, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusMemAddr_Initialize(asn1SccPusMemAddr* pVal)
{
    *pVal = (asn1SccPusMemAddr) 0;
}
#endif

 
flag asn1SccPusMemAddr_IsConstraintValid(const asn1SccPusMemAddr* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt64_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusMemAddr_Encode(const asn1SccPusMemAddr* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusMemAddr_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt64_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusMemAddr_Decode(asn1SccPusMemAddr* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt64_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusMemAddr_ACN_Encode(const asn1SccPusMemAddr* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusMemAddr_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt64_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusMemAddr_ACN_Decode(asn1SccPusMemAddr* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt64_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt20StoredParam_Initialize(asn1SccPusSt20StoredParam* pVal)
{
    *pVal = (asn1SccPusSt20StoredParam) 0;
}
#endif

 
flag asn1SccPusSt20StoredParam_IsConstraintValid(const asn1SccPusSt20StoredParam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusUInt64_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccPusSt20StoredParam_Encode(const asn1SccPusSt20StoredParam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt20StoredParam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt64_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt20StoredParam_Decode(asn1SccPusSt20StoredParam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccPusUInt64_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag asn1SccPusSt20StoredParam_ACN_Encode(const asn1SccPusSt20StoredParam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt20StoredParam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccPusUInt64_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccPusSt20StoredParam_ACN_Decode(asn1SccPusSt20StoredParam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccPusUInt64_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_TM_20_X_Data_Initialize(asn1SccPusTC_TM_20_X_Data* pVal)
{
    *pVal = (asn1SccPusTC_TM_20_X_Data) {
    .paramId = 0,
    .value = 0
};
}
#endif

 
flag asn1SccPusTC_TM_20_X_Data_IsConstraintValid(const asn1SccPusTC_TM_20_X_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt20OnBoardParameterId_IsConstraintValid(&pVal->paramId, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt20StoredParam_IsConstraintValid(&pVal->value, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTC_TM_20_X_Data_Encode(const asn1SccPusTC_TM_20_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_TM_20_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode paramId */
	    ret = asn1SccPusSt20OnBoardParameterId_Encode(&pVal->paramId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode value */
	        ret = asn1SccPusSt20StoredParam_Encode(&pVal->value, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTC_TM_20_X_Data_Decode(asn1SccPusTC_TM_20_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode paramId */
	ret = asn1SccPusSt20OnBoardParameterId_Decode(&pVal->paramId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode value */
	    ret = asn1SccPusSt20StoredParam_Decode(&pVal->value, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTC_TM_20_X_Data_ACN_Encode(const asn1SccPusTC_TM_20_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_TM_20_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode paramId */
	    ret = asn1SccPusSt20OnBoardParameterId_ACN_Encode(&pVal->paramId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode value */
	        ret = asn1SccPusSt20StoredParam_ACN_Encode(&pVal->value, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTC_TM_20_X_Data_ACN_Decode(asn1SccPusTC_TM_20_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode paramId */
    ret = asn1SccPusSt20OnBoardParameterId_ACN_Decode(&pVal->paramId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode value */
        ret = asn1SccPusSt20StoredParam_ACN_Decode(&pVal->value, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTcApplicationDataReduced_Initialize(asn1SccPusTcApplicationDataReduced* pVal)
{
    *pVal = (asn1SccPusTcApplicationDataReduced) {
    .kind = PusTcApplicationDataReduced_st_8_1_PRESENT,
    .u = { .st_8_1 = {
    .functionId = 0
}}
};
}
#endif

 
flag asn1SccPusTcApplicationDataReduced_IsConstraintValid(const asn1SccPusTcApplicationDataReduced* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case PusTcApplicationDataReduced_st_8_1_PRESENT :
	        ret = asn1SccPusTC_8_1_Data_IsConstraintValid(&pVal->u.st_8_1, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_9_1_PRESENT :
	        ret = asn1SccPusTC_9_1_Data_IsConstraintValid(&pVal->u.st_9_1, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_12_1_2_PRESENT :
	        ret = asn1SccPusTC_12_1_2_Data_IsConstraintValid(&pVal->u.st_12_1_2, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_18_1_PRESENT :
	        ret = asn1SccPusTC_18_1_Data_IsConstraintValid(&pVal->u.st_18_1, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_18_2_6_12_PRESENT :
	        ret = asn1SccPusTC_18_2_6_12_Data_IsConstraintValid(&pVal->u.st_18_2_6_12, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_18_3_PRESENT :
	        ret = asn1SccPusTC_18_3_Data_IsConstraintValid(&pVal->u.st_18_3, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_18_4_5_PRESENT :
	        ret = asn1SccPusTC_18_4_5_Data_IsConstraintValid(&pVal->u.st_18_4_5, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_18_13_PRESENT :
	        ret = asn1SccPusTC_18_13_Data_IsConstraintValid(&pVal->u.st_18_13, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_19_X_PRESENT :
	        ret = asn1SccPusTC_19_X_Data_IsConstraintValid(&pVal->u.st_19_X, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_20_X_PRESENT :
	        ret = asn1SccPusTC_TM_20_X_Data_IsConstraintValid(&pVal->u.st_20_X, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_23_1_PRESENT :
	        ret = asn1SccPusTC_TM_23_1_4_Data_IsConstraintValid(&pVal->u.st_23_1, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_23_2_3_PRESENT :
	        ret = asn1SccPusTC_23_2_3_Data_IsConstraintValid(&pVal->u.st_23_2_3, pErrCode);
	        break;
	    case PusTcApplicationDataReduced_st_23_14_PRESENT :
	        ret = asn1SccPusTC_23_14_Data_IsConstraintValid(&pVal->u.st_23_14, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag asn1SccPusTcApplicationDataReduced_Encode(const asn1SccPusTcApplicationDataReduced* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTcApplicationDataReduced_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusTcApplicationDataReduced_st_8_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 12);
	    	ret = asn1SccPusTC_8_1_Data_Encode(&pVal->u.st_8_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_9_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 12);
	    	ret = asn1SccPusTC_9_1_Data_Encode(&pVal->u.st_9_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_12_1_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 12);
	    	ret = asn1SccPusTC_12_1_2_Data_Encode(&pVal->u.st_12_1_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 12);
	    	ret = asn1SccPusTC_18_1_Data_Encode(&pVal->u.st_18_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_2_6_12_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 12);
	    	ret = asn1SccPusTC_18_2_6_12_Data_Encode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 12);
	    	ret = asn1SccPusTC_18_3_Data_Encode(&pVal->u.st_18_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_4_5_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 12);
	    	ret = asn1SccPusTC_18_4_5_Data_Encode(&pVal->u.st_18_4_5, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_13_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 12);
	    	ret = asn1SccPusTC_18_13_Data_Encode(&pVal->u.st_18_13, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_19_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 12);
	    	ret = asn1SccPusTC_19_X_Data_Encode(&pVal->u.st_19_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_20_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 12);
	    	ret = asn1SccPusTC_TM_20_X_Data_Encode(&pVal->u.st_20_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_23_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 12);
	    	ret = asn1SccPusTC_TM_23_1_4_Data_Encode(&pVal->u.st_23_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_23_2_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 12);
	    	ret = asn1SccPusTC_23_2_3_Data_Encode(&pVal->u.st_23_2_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_23_14_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 12);
	    	ret = asn1SccPusTC_23_14_Data_Encode(&pVal->u.st_23_14, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusTcApplicationDataReduced_Decode(asn1SccPusTcApplicationDataReduced* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 12);
	*pErrCode = ret ? 0 : 268435521;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = PusTcApplicationDataReduced_st_8_1_PRESENT;
	    	ret = asn1SccPusTC_8_1_Data_Decode(&pVal->u.st_8_1, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PusTcApplicationDataReduced_st_9_1_PRESENT;
	    	ret = asn1SccPusTC_9_1_Data_Decode(&pVal->u.st_9_1, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = PusTcApplicationDataReduced_st_12_1_2_PRESENT;
	    	ret = asn1SccPusTC_12_1_2_Data_Decode(&pVal->u.st_12_1_2, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = PusTcApplicationDataReduced_st_18_1_PRESENT;
	    	ret = asn1SccPusTC_18_1_Data_Decode(&pVal->u.st_18_1, pBitStrm, pErrCode);
	    	break;
	    case 4:
	    	pVal->kind = PusTcApplicationDataReduced_st_18_2_6_12_PRESENT;
	    	ret = asn1SccPusTC_18_2_6_12_Data_Decode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode);
	    	break;
	    case 5:
	    	pVal->kind = PusTcApplicationDataReduced_st_18_3_PRESENT;
	    	ret = asn1SccPusTC_18_3_Data_Decode(&pVal->u.st_18_3, pBitStrm, pErrCode);
	    	break;
	    case 6:
	    	pVal->kind = PusTcApplicationDataReduced_st_18_4_5_PRESENT;
	    	ret = asn1SccPusTC_18_4_5_Data_Decode(&pVal->u.st_18_4_5, pBitStrm, pErrCode);
	    	break;
	    case 7:
	    	pVal->kind = PusTcApplicationDataReduced_st_18_13_PRESENT;
	    	ret = asn1SccPusTC_18_13_Data_Decode(&pVal->u.st_18_13, pBitStrm, pErrCode);
	    	break;
	    case 8:
	    	pVal->kind = PusTcApplicationDataReduced_st_19_X_PRESENT;
	    	ret = asn1SccPusTC_19_X_Data_Decode(&pVal->u.st_19_X, pBitStrm, pErrCode);
	    	break;
	    case 9:
	    	pVal->kind = PusTcApplicationDataReduced_st_20_X_PRESENT;
	    	ret = asn1SccPusTC_TM_20_X_Data_Decode(&pVal->u.st_20_X, pBitStrm, pErrCode);
	    	break;
	    case 10:
	    	pVal->kind = PusTcApplicationDataReduced_st_23_1_PRESENT;
	    	ret = asn1SccPusTC_TM_23_1_4_Data_Decode(&pVal->u.st_23_1, pBitStrm, pErrCode);
	    	break;
	    case 11:
	    	pVal->kind = PusTcApplicationDataReduced_st_23_2_3_PRESENT;
	    	ret = asn1SccPusTC_23_2_3_Data_Decode(&pVal->u.st_23_2_3, pBitStrm, pErrCode);
	    	break;
	    case 12:
	    	pVal->kind = PusTcApplicationDataReduced_st_23_14_PRESENT;
	    	ret = asn1SccPusTC_23_14_Data_Decode(&pVal->u.st_23_14, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusTcApplicationDataReduced_ACN_Encode(const asn1SccPusTcApplicationDataReduced* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTcApplicationDataReduced_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusTcApplicationDataReduced_st_8_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 12);
	    	ret = asn1SccPusTC_8_1_Data_ACN_Encode(&pVal->u.st_8_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_9_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 12);
	    	ret = asn1SccPusTC_9_1_Data_ACN_Encode(&pVal->u.st_9_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_12_1_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 12);
	    	ret = asn1SccPusTC_12_1_2_Data_ACN_Encode(&pVal->u.st_12_1_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 12);
	    	ret = asn1SccPusTC_18_1_Data_ACN_Encode(&pVal->u.st_18_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_2_6_12_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 12);
	    	ret = asn1SccPusTC_18_2_6_12_Data_ACN_Encode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 12);
	    	ret = asn1SccPusTC_18_3_Data_ACN_Encode(&pVal->u.st_18_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_4_5_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 12);
	    	ret = asn1SccPusTC_18_4_5_Data_ACN_Encode(&pVal->u.st_18_4_5, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_18_13_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 12);
	    	ret = asn1SccPusTC_18_13_Data_ACN_Encode(&pVal->u.st_18_13, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_19_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 12);
	    	ret = asn1SccPusTC_19_X_Data_ACN_Encode(&pVal->u.st_19_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_20_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 12);
	    	ret = asn1SccPusTC_TM_20_X_Data_ACN_Encode(&pVal->u.st_20_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_23_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 12);
	    	ret = asn1SccPusTC_TM_23_1_4_Data_ACN_Encode(&pVal->u.st_23_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_23_2_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 12);
	    	ret = asn1SccPusTC_23_2_3_Data_ACN_Encode(&pVal->u.st_23_2_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationDataReduced_st_23_14_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 12);
	    	ret = asn1SccPusTC_23_14_Data_ACN_Encode(&pVal->u.st_23_14, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306372;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusTcApplicationDataReduced_ACN_Decode(asn1SccPusTcApplicationDataReduced* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 12);
    *pErrCode = ret ? 0 : 268435522;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = PusTcApplicationDataReduced_st_8_1_PRESENT;
        	ret = asn1SccPusTC_8_1_Data_ACN_Decode(&pVal->u.st_8_1, pBitStrm, pErrCode);
        	break;
        case 1:
        	pVal->kind = PusTcApplicationDataReduced_st_9_1_PRESENT;
        	ret = asn1SccPusTC_9_1_Data_ACN_Decode(&pVal->u.st_9_1, pBitStrm, pErrCode);
        	break;
        case 2:
        	pVal->kind = PusTcApplicationDataReduced_st_12_1_2_PRESENT;
        	ret = asn1SccPusTC_12_1_2_Data_ACN_Decode(&pVal->u.st_12_1_2, pBitStrm, pErrCode);
        	break;
        case 3:
        	pVal->kind = PusTcApplicationDataReduced_st_18_1_PRESENT;
        	ret = asn1SccPusTC_18_1_Data_ACN_Decode(&pVal->u.st_18_1, pBitStrm, pErrCode);
        	break;
        case 4:
        	pVal->kind = PusTcApplicationDataReduced_st_18_2_6_12_PRESENT;
        	ret = asn1SccPusTC_18_2_6_12_Data_ACN_Decode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode);
        	break;
        case 5:
        	pVal->kind = PusTcApplicationDataReduced_st_18_3_PRESENT;
        	ret = asn1SccPusTC_18_3_Data_ACN_Decode(&pVal->u.st_18_3, pBitStrm, pErrCode);
        	break;
        case 6:
        	pVal->kind = PusTcApplicationDataReduced_st_18_4_5_PRESENT;
        	ret = asn1SccPusTC_18_4_5_Data_ACN_Decode(&pVal->u.st_18_4_5, pBitStrm, pErrCode);
        	break;
        case 7:
        	pVal->kind = PusTcApplicationDataReduced_st_18_13_PRESENT;
        	ret = asn1SccPusTC_18_13_Data_ACN_Decode(&pVal->u.st_18_13, pBitStrm, pErrCode);
        	break;
        case 8:
        	pVal->kind = PusTcApplicationDataReduced_st_19_X_PRESENT;
        	ret = asn1SccPusTC_19_X_Data_ACN_Decode(&pVal->u.st_19_X, pBitStrm, pErrCode);
        	break;
        case 9:
        	pVal->kind = PusTcApplicationDataReduced_st_20_X_PRESENT;
        	ret = asn1SccPusTC_TM_20_X_Data_ACN_Decode(&pVal->u.st_20_X, pBitStrm, pErrCode);
        	break;
        case 10:
        	pVal->kind = PusTcApplicationDataReduced_st_23_1_PRESENT;
        	ret = asn1SccPusTC_TM_23_1_4_Data_ACN_Decode(&pVal->u.st_23_1, pBitStrm, pErrCode);
        	break;
        case 11:
        	pVal->kind = PusTcApplicationDataReduced_st_23_2_3_PRESENT;
        	ret = asn1SccPusTC_23_2_3_Data_ACN_Decode(&pVal->u.st_23_2_3, pBitStrm, pErrCode);
        	break;
        case 12:
        	pVal->kind = PusTcApplicationDataReduced_st_23_14_PRESENT;
        	ret = asn1SccPusTC_23_14_Data_ACN_Decode(&pVal->u.st_23_14, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306373;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketDataReduced_tcData_Initialize(asn1SccPusPacketDataReduced_tcData* pVal)
{
    *pVal = (asn1SccPusPacketDataReduced_tcData) {
    .header = {
        .pusVersion = asn1Sccpus_V0,
        .ackFlags = {
            .acceptanceReportRequested = FALSE,
            .startReportRequested = FALSE,
            .progressReportRequested = FALSE,
            .completionReportRequested = FALSE
        },
        .serviceId = 0,
        .subtype = 0,
        .source = 0
    },
    .data = {
        .kind = PusTcApplicationDataReduced_st_8_1_PRESENT,
        .u = { .st_8_1 = {
        .functionId = 0
    }}
    }
};
}
#endif

 
flag asn1SccPusPacketDataReduced_tcData_IsConstraintValid(const asn1SccPusPacketDataReduced_tcData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusTcHeader_IsConstraintValid(&pVal->header, pErrCode);
	if (ret) {
	    ret = asn1SccPusTcApplicationDataReduced_IsConstraintValid(&pVal->data, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusPacketDataReduced_tcData_Encode(const asn1SccPusPacketDataReduced_tcData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketDataReduced_tcData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode header */
	    ret = asn1SccPusTcHeader_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusTcApplicationDataReduced_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusPacketDataReduced_tcData_Decode(asn1SccPusPacketDataReduced_tcData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode header */
	ret = asn1SccPusTcHeader_Decode(&pVal->header, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccPusTcApplicationDataReduced_Decode(&pVal->data, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusPacketDataReduced_tcData_ACN_Encode(const asn1SccPusPacketDataReduced_tcData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacketDataReduced_tcData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode header */
	    ret = asn1SccPusTcHeader_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusTcApplicationDataReduced_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusPacketDataReduced_tcData_ACN_Decode(asn1SccPusPacketDataReduced_tcData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode header */
    ret = asn1SccPusTcHeader_ACN_Decode(&pVal->header, pBitStrm, pErrCode);
    if (ret) {
        /*Decode data */
        ret = asn1SccPusTcApplicationDataReduced_ACN_Decode(&pVal->data, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusInt32_Initialize(asn1SccPusInt32* pVal)
{
    *pVal = (asn1SccPusInt32) -2147483648LL;
}
#endif

 
flag asn1SccPusInt32_IsConstraintValid(const asn1SccPusInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_asn1SccPusInt32;

	return ret;
}

flag asn1SccPusInt32_Encode(const asn1SccPusInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag asn1SccPusInt32_Decode(asn1SccPusInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : 268435523;

	return ret;
}

flag asn1SccPusInt32_ACN_Encode(const asn1SccPusInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag asn1SccPusInt32_ACN_Decode(asn1SccPusInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
    *pErrCode = ret ? 0 : 268435524;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt01FailureInfo_Initialize(asn1SccPusSt01FailureInfo* pVal)
{
    *pVal = (asn1SccPusSt01FailureInfo) {
    .subcode = -2147483648LL,
    .data = -2147483648LL,
    .address = 0
};
}
#endif

 
flag asn1SccPusSt01FailureInfo_IsConstraintValid(const asn1SccPusSt01FailureInfo* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusInt32_IsConstraintValid(&pVal->subcode, pErrCode);
	if (ret) {
	    ret = asn1SccPusInt32_IsConstraintValid(&pVal->data, pErrCode);
	    if (ret) {
	        ret = asn1SccPusMemAddr_IsConstraintValid(&pVal->address, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccPusSt01FailureInfo_Encode(const asn1SccPusSt01FailureInfo* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt01FailureInfo_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode subcode */
	    ret = asn1SccPusInt32_Encode(&pVal->subcode, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusInt32_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode address */
	            ret = asn1SccPusMemAddr_Encode(&pVal->address, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccPusSt01FailureInfo_Decode(asn1SccPusSt01FailureInfo* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode subcode */
	ret = asn1SccPusInt32_Decode(&pVal->subcode, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccPusInt32_Decode(&pVal->data, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode address */
	        ret = asn1SccPusMemAddr_Decode(&pVal->address, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag asn1SccPusSt01FailureInfo_ACN_Encode(const asn1SccPusSt01FailureInfo* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt01FailureInfo_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode subcode */
	    ret = asn1SccPusInt32_ACN_Encode(&pVal->subcode, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusInt32_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode address */
	            ret = asn1SccPusMemAddr_ACN_Encode(&pVal->address, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag asn1SccPusSt01FailureInfo_ACN_Decode(asn1SccPusSt01FailureInfo* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode subcode */
    ret = asn1SccPusInt32_ACN_Decode(&pVal->subcode, pBitStrm, pErrCode);
    if (ret) {
        /*Decode data */
        ret = asn1SccPusInt32_ACN_Decode(&pVal->data, pBitStrm, pErrCode);
        if (ret) {
            /*Decode address */
            ret = asn1SccPusMemAddr_ACN_Decode(&pVal->address, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusSt01Failure_Initialize(asn1SccPusSt01Failure* pVal)
{
    *pVal = (asn1SccPusSt01Failure) {
    .code = 0,
    .info = {
        .subcode = -2147483648LL,
        .data = -2147483648LL,
        .address = 0
    }
};
}
#endif

 
flag asn1SccPusSt01Failure_IsConstraintValid(const asn1SccPusSt01Failure* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt01FailureCode_IsConstraintValid(&pVal->code, pErrCode);
	if (ret) {
	    ret = asn1SccPusSt01FailureInfo_IsConstraintValid(&pVal->info, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusSt01Failure_Encode(const asn1SccPusSt01Failure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusSt01Failure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode code */
	    ret = asn1SccPusSt01FailureCode_Encode(&pVal->code, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode info */
	        ret = asn1SccPusSt01FailureInfo_Encode(&pVal->info, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusSt01Failure_Decode(asn1SccPusSt01Failure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode code */
	ret = asn1SccPusSt01FailureCode_Decode(&pVal->code, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode info */
	    ret = asn1SccPusSt01FailureInfo_Decode(&pVal->info, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusSt01Failure_ACN_Encode(const asn1SccPusSt01Failure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusSt01Failure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode code */
	    ret = asn1SccPusSt01FailureCode_ACN_Encode(&pVal->code, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode info */
	        ret = asn1SccPusSt01FailureInfo_ACN_Encode(&pVal->info, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusSt01Failure_ACN_Decode(asn1SccPusSt01Failure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode code */
    ret = asn1SccPusSt01FailureCode_ACN_Decode(&pVal->code, pBitStrm, pErrCode);
    if (ret) {
        /*Decode info */
        ret = asn1SccPusSt01FailureInfo_ACN_Decode(&pVal->info, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTM_1_X_Data_Initialize(asn1SccPusTM_1_X_Data* pVal)
{
    *pVal = (asn1SccPusTM_1_X_Data) {
    .request = {
        .packetVersion = asn1Sccpus_CCSDS_V1,
        .packetType = asn1Sccpus_TM,
        .secondaryHeaderFlag = FALSE,
        .apid = 0,
        .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
        .sequenceCount = 0
    },
    .step = 0,
    .failure = {
        .code = 0,
        .info = {
            .subcode = -2147483648LL,
            .data = -2147483648LL,
            .address = 0
        }
    }
};
}
#endif

 
flag asn1SccPusTM_1_X_Data_IsConstraintValid(const asn1SccPusTM_1_X_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt01RequestId_IsConstraintValid(&pVal->request, pErrCode);
	if (ret) {
	    ret = asn1SccPusStepId_IsConstraintValid(&pVal->step, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSt01Failure_IsConstraintValid(&pVal->failure, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccPusTM_1_X_Data_Encode(const asn1SccPusTM_1_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTM_1_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode request */
	    ret = asn1SccPusSt01RequestId_Encode(&pVal->request, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode step */
	        ret = asn1SccPusStepId_Encode(&pVal->step, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode failure */
	            ret = asn1SccPusSt01Failure_Encode(&pVal->failure, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTM_1_X_Data_Decode(asn1SccPusTM_1_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode request */
	ret = asn1SccPusSt01RequestId_Decode(&pVal->request, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode step */
	    ret = asn1SccPusStepId_Decode(&pVal->step, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode failure */
	        ret = asn1SccPusSt01Failure_Decode(&pVal->failure, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag asn1SccPusTM_1_X_Data_ACN_Encode(const asn1SccPusTM_1_X_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTM_1_X_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode request */
	    ret = asn1SccPusSt01RequestId_ACN_Encode(&pVal->request, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode step */
	        ret = asn1SccPusStepId_ACN_Encode(&pVal->step, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode failure */
	            ret = asn1SccPusSt01Failure_ACN_Encode(&pVal->failure, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTM_1_X_Data_ACN_Decode(asn1SccPusTM_1_X_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode request */
    ret = asn1SccPusSt01RequestId_ACN_Decode(&pVal->request, pBitStrm, pErrCode);
    if (ret) {
        /*Decode step */
        ret = asn1SccPusStepId_ACN_Decode(&pVal->step, pBitStrm, pErrCode);
        if (ret) {
            /*Decode failure */
            ret = asn1SccPusSt01Failure_ACN_Decode(&pVal->failure, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusInt64_Initialize(asn1SccPusInt64* pVal)
{
    *pVal = (asn1SccPusInt64) LLONG_MIN;
}
#endif

 
flag asn1SccPusInt64_IsConstraintValid(const asn1SccPusInt64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (LLONG_MIN <= *pVal && *pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccPusInt64;

	return ret;
}

flag asn1SccPusInt64_Encode(const asn1SccPusInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, LLONG_MIN, 9223372036854775807LL);
    }

	return ret;
}

flag asn1SccPusInt64_Decode(asn1SccPusInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : 268435525;

	return ret;
}

flag asn1SccPusInt64_ACN_Encode(const asn1SccPusInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, LLONG_MIN, 9223372036854775807LL);
    }

	return ret;
}

flag asn1SccPusInt64_ACN_Decode(asn1SccPusInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
    *pErrCode = ret ? 0 : 268435526;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTime_Initialize(asn1SccPusTime* pVal)
{
    *pVal = (asn1SccPusTime) {
    .tv_sec = LLONG_MIN,
    .tv_nsec = LLONG_MIN
};
}
#endif

 
flag asn1SccPusTime_IsConstraintValid(const asn1SccPusTime* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusInt64_IsConstraintValid(&pVal->tv_sec, pErrCode);
	if (ret) {
	    ret = asn1SccPusInt64_IsConstraintValid(&pVal->tv_nsec, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTime_Encode(const asn1SccPusTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode tv_sec */
	    ret = asn1SccPusInt64_Encode(&pVal->tv_sec, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tv_nsec */
	        ret = asn1SccPusInt64_Encode(&pVal->tv_nsec, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTime_Decode(asn1SccPusTime* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode tv_sec */
	ret = asn1SccPusInt64_Decode(&pVal->tv_sec, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode tv_nsec */
	    ret = asn1SccPusInt64_Decode(&pVal->tv_nsec, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTime_ACN_Encode(const asn1SccPusTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode tv_sec */
	    ret = asn1SccPusInt64_ACN_Encode(&pVal->tv_sec, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode tv_nsec */
	        ret = asn1SccPusInt64_ACN_Encode(&pVal->tv_nsec, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTime_ACN_Decode(asn1SccPusTime* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode tv_sec */
    ret = asn1SccPusInt64_ACN_Decode(&pVal->tv_sec, pBitStrm, pErrCode);
    if (ret) {
        /*Decode tv_nsec */
        ret = asn1SccPusInt64_ACN_Decode(&pVal->tv_nsec, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTmHeader_Initialize(asn1SccPusTmHeader* pVal)
{
    *pVal = (asn1SccPusTmHeader) {
    .pusVersion = asn1Sccpus_V0,
    .timeRefStatus = 0,
    .serviceId = 0,
    .subtype = 0,
    .msgTypeCount = 0,
    .destination = 0,
    .time = {
        .tv_sec = LLONG_MIN,
        .tv_nsec = LLONG_MIN
    }
};
}
#endif

 
flag asn1SccPusTmHeader_IsConstraintValid(const asn1SccPusTmHeader* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusVersionNumber_IsConstraintValid(&pVal->pusVersion, pErrCode);
	if (ret) {
	    ret = asn1SccPusTimeReferenceStatus_IsConstraintValid(&pVal->timeRefStatus, pErrCode);
	    if (ret) {
	        ret = asn1SccPusServiceType_IsConstraintValid(&pVal->serviceId, pErrCode);
	        if (ret) {
	            ret = asn1SccPusSubserviceType_IsConstraintValid(&pVal->subtype, pErrCode);
	            if (ret) {
	                ret = asn1SccPusMessageTypeCounter_IsConstraintValid(&pVal->msgTypeCount, pErrCode);
	                if (ret) {
	                    ret = asn1SccPusApid_IsConstraintValid(&pVal->destination, pErrCode);
	                    if (ret) {
	                        ret = asn1SccPusTime_IsConstraintValid(&pVal->time, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccPusTmHeader_Encode(const asn1SccPusTmHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTmHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pusVersion */
	    ret = asn1SccPusVersionNumber_Encode(&pVal->pusVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timeRefStatus */
	        ret = asn1SccPusTimeReferenceStatus_Encode(&pVal->timeRefStatus, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode serviceId */
	            ret = asn1SccPusServiceType_Encode(&pVal->serviceId, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode subtype */
	                ret = asn1SccPusSubserviceType_Encode(&pVal->subtype, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode msgTypeCount */
	                    ret = asn1SccPusMessageTypeCounter_Encode(&pVal->msgTypeCount, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode destination */
	                        ret = asn1SccPusApid_Encode(&pVal->destination, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode time */
	                            ret = asn1SccPusTime_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusTmHeader_Decode(asn1SccPusTmHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pusVersion */
	ret = asn1SccPusVersionNumber_Decode(&pVal->pusVersion, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timeRefStatus */
	    ret = asn1SccPusTimeReferenceStatus_Decode(&pVal->timeRefStatus, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode serviceId */
	        ret = asn1SccPusServiceType_Decode(&pVal->serviceId, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode subtype */
	            ret = asn1SccPusSubserviceType_Decode(&pVal->subtype, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode msgTypeCount */
	                ret = asn1SccPusMessageTypeCounter_Decode(&pVal->msgTypeCount, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode destination */
	                    ret = asn1SccPusApid_Decode(&pVal->destination, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode time */
	                        ret = asn1SccPusTime_Decode(&pVal->time, pBitStrm, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag asn1SccPusTmHeader_ACN_Encode(const asn1SccPusTmHeader* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTmHeader_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pusVersion */
	    ret = asn1SccPusVersionNumber_ACN_Encode(&pVal->pusVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timeRefStatus */
	        ret = asn1SccPusTimeReferenceStatus_ACN_Encode(&pVal->timeRefStatus, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode serviceId */
	            ret = asn1SccPusServiceType_ACN_Encode(&pVal->serviceId, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode subtype */
	                ret = asn1SccPusSubserviceType_ACN_Encode(&pVal->subtype, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode msgTypeCount */
	                    ret = asn1SccPusMessageTypeCounter_ACN_Encode(&pVal->msgTypeCount, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode destination */
	                        ret = asn1SccPusApid_ACN_Encode(&pVal->destination, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode time */
	                            ret = asn1SccPusTime_ACN_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusTmHeader_ACN_Decode(asn1SccPusTmHeader* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode pusVersion */
    ret = asn1SccPusVersionNumber_ACN_Decode(&pVal->pusVersion, pBitStrm, pErrCode);
    if (ret) {
        /*Decode timeRefStatus */
        ret = asn1SccPusTimeReferenceStatus_ACN_Decode(&pVal->timeRefStatus, pBitStrm, pErrCode);
        if (ret) {
            /*Decode serviceId */
            ret = asn1SccPusServiceType_ACN_Decode(&pVal->serviceId, pBitStrm, pErrCode);
            if (ret) {
                /*Decode subtype */
                ret = asn1SccPusSubserviceType_ACN_Decode(&pVal->subtype, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode msgTypeCount */
                    ret = asn1SccPusMessageTypeCounter_ACN_Decode(&pVal->msgTypeCount, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode destination */
                        ret = asn1SccPusApid_ACN_Decode(&pVal->destination, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode time */
                            ret = asn1SccPusTime_ACN_Decode(&pVal->time, pBitStrm, pErrCode);

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTM_9_2_Data_Initialize(asn1SccPusTM_9_2_Data* pVal)
{
    *pVal = (asn1SccPusTM_9_2_Data) {
    .exponentialRate = 0,
    .time = {
        .tv_sec = LLONG_MIN,
        .tv_nsec = LLONG_MIN
    }
};
}
#endif

 
flag asn1SccPusTM_9_2_Data_IsConstraintValid(const asn1SccPusTM_9_2_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt09ExponentialRate_IsConstraintValid(&pVal->exponentialRate, pErrCode);
	if (ret) {
	    ret = asn1SccPusTime_IsConstraintValid(&pVal->time, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTM_9_2_Data_Encode(const asn1SccPusTM_9_2_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTM_9_2_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode exponentialRate */
	    ret = asn1SccPusSt09ExponentialRate_Encode(&pVal->exponentialRate, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode time */
	        ret = asn1SccPusTime_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTM_9_2_Data_Decode(asn1SccPusTM_9_2_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode exponentialRate */
	ret = asn1SccPusSt09ExponentialRate_Decode(&pVal->exponentialRate, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode time */
	    ret = asn1SccPusTime_Decode(&pVal->time, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTM_9_2_Data_ACN_Encode(const asn1SccPusTM_9_2_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTM_9_2_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode exponentialRate */
	    ret = asn1SccPusSt09ExponentialRate_ACN_Encode(&pVal->exponentialRate, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode time */
	        ret = asn1SccPusTime_ACN_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTM_9_2_Data_ACN_Decode(asn1SccPusTM_9_2_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode exponentialRate */
    ret = asn1SccPusSt09ExponentialRate_ACN_Decode(&pVal->exponentialRate, pBitStrm, pErrCode);
    if (ret) {
        /*Decode time */
        ret = asn1SccPusTime_ACN_Decode(&pVal->time, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTmSourceData_Initialize(asn1SccPusTmSourceData* pVal)
{
    *pVal = (asn1SccPusTmSourceData) {
    .kind = st_1_X_PRESENT,
    .u = { .st_1_X = {
    .request = {
        .packetVersion = asn1Sccpus_CCSDS_V1,
        .packetType = asn1Sccpus_TM,
        .secondaryHeaderFlag = FALSE,
        .apid = 0,
        .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
        .sequenceCount = 0
    },
    .step = 0,
    .failure = {
        .code = 0,
        .info = {
            .subcode = -2147483648LL,
            .data = -2147483648LL,
            .address = 0
        }
    }
}}
};
}
#endif

 
flag asn1SccPusTmSourceData_IsConstraintValid(const asn1SccPusTmSourceData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case st_1_X_PRESENT :
	        ret = asn1SccPusTM_1_X_Data_IsConstraintValid(&pVal->u.st_1_X, pErrCode);
	        break;
	    case st_3_25_PRESENT :
	        ret = asn1SccPusTM_3_25_Data_IsConstraintValid(&pVal->u.st_3_25, pErrCode);
	        break;
	    case st_5_X_PRESENT :
	        ret = asn1SccPusTM_5_X_Data_IsConstraintValid(&pVal->u.st_5_X, pErrCode);
	        break;
	    case st_9_2_PRESENT :
	        ret = asn1SccPusTM_9_2_Data_IsConstraintValid(&pVal->u.st_9_2, pErrCode);
	        break;
	    case st_20_2_PRESENT :
	        ret = asn1SccPusTC_TM_20_X_Data_IsConstraintValid(&pVal->u.st_20_2, pErrCode);
	        break;
	    case st_23_4_PRESENT :
	        ret = asn1SccPusTC_TM_23_1_4_Data_IsConstraintValid(&pVal->u.st_23_4, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306374;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag asn1SccPusTmSourceData_Encode(const asn1SccPusTmSourceData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTmSourceData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case st_1_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	    	ret = asn1SccPusTM_1_X_Data_Encode(&pVal->u.st_1_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_3_25_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	    	ret = asn1SccPusTM_3_25_Data_Encode(&pVal->u.st_3_25, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_5_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	    	ret = asn1SccPusTM_5_X_Data_Encode(&pVal->u.st_5_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_9_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	    	ret = asn1SccPusTM_9_2_Data_Encode(&pVal->u.st_9_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_20_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	    	ret = asn1SccPusTC_TM_20_X_Data_Encode(&pVal->u.st_20_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_23_4_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	    	ret = asn1SccPusTC_TM_23_1_4_Data_Encode(&pVal->u.st_23_4, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306375;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusTmSourceData_Decode(asn1SccPusTmSourceData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 5);
	*pErrCode = ret ? 0 : 268435527;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = st_1_X_PRESENT;
	    	ret = asn1SccPusTM_1_X_Data_Decode(&pVal->u.st_1_X, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = st_3_25_PRESENT;
	    	ret = asn1SccPusTM_3_25_Data_Decode(&pVal->u.st_3_25, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = st_5_X_PRESENT;
	    	ret = asn1SccPusTM_5_X_Data_Decode(&pVal->u.st_5_X, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = st_9_2_PRESENT;
	    	ret = asn1SccPusTM_9_2_Data_Decode(&pVal->u.st_9_2, pBitStrm, pErrCode);
	    	break;
	    case 4:
	    	pVal->kind = st_20_2_PRESENT;
	    	ret = asn1SccPusTC_TM_20_X_Data_Decode(&pVal->u.st_20_2, pBitStrm, pErrCode);
	    	break;
	    case 5:
	    	pVal->kind = st_23_4_PRESENT;
	    	ret = asn1SccPusTC_TM_23_1_4_Data_Decode(&pVal->u.st_23_4, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306376;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusTmSourceData_ACN_Encode(const asn1SccPusTmSourceData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTmSourceData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case st_1_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	    	ret = asn1SccPusTM_1_X_Data_ACN_Encode(&pVal->u.st_1_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_3_25_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	    	ret = asn1SccPusTM_3_25_Data_ACN_Encode(&pVal->u.st_3_25, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_5_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	    	ret = asn1SccPusTM_5_X_Data_ACN_Encode(&pVal->u.st_5_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_9_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	    	ret = asn1SccPusTM_9_2_Data_ACN_Encode(&pVal->u.st_9_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_20_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	    	ret = asn1SccPusTC_TM_20_X_Data_ACN_Encode(&pVal->u.st_20_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_23_4_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	    	ret = asn1SccPusTC_TM_23_1_4_Data_ACN_Encode(&pVal->u.st_23_4, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306377;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusTmSourceData_ACN_Decode(asn1SccPusTmSourceData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 5);
    *pErrCode = ret ? 0 : 268435528;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = st_1_X_PRESENT;
        	ret = asn1SccPusTM_1_X_Data_ACN_Decode(&pVal->u.st_1_X, pBitStrm, pErrCode);
        	break;
        case 1:
        	pVal->kind = st_3_25_PRESENT;
        	ret = asn1SccPusTM_3_25_Data_ACN_Decode(&pVal->u.st_3_25, pBitStrm, pErrCode);
        	break;
        case 2:
        	pVal->kind = st_5_X_PRESENT;
        	ret = asn1SccPusTM_5_X_Data_ACN_Decode(&pVal->u.st_5_X, pBitStrm, pErrCode);
        	break;
        case 3:
        	pVal->kind = st_9_2_PRESENT;
        	ret = asn1SccPusTM_9_2_Data_ACN_Decode(&pVal->u.st_9_2, pBitStrm, pErrCode);
        	break;
        case 4:
        	pVal->kind = st_20_2_PRESENT;
        	ret = asn1SccPusTC_TM_20_X_Data_ACN_Decode(&pVal->u.st_20_2, pBitStrm, pErrCode);
        	break;
        case 5:
        	pVal->kind = st_23_4_PRESENT;
        	ret = asn1SccPusTC_TM_23_1_4_Data_ACN_Decode(&pVal->u.st_23_4, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306378;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTmHeaderData_Initialize(asn1SccPusTmHeaderData* pVal)
{
    *pVal = (asn1SccPusTmHeaderData) {
    .header = {
        .pusVersion = asn1Sccpus_V0,
        .timeRefStatus = 0,
        .serviceId = 0,
        .subtype = 0,
        .msgTypeCount = 0,
        .destination = 0,
        .time = {
            .tv_sec = LLONG_MIN,
            .tv_nsec = LLONG_MIN
        }
    },
    .data = {
        .kind = st_1_X_PRESENT,
        .u = { .st_1_X = {
        .request = {
            .packetVersion = asn1Sccpus_CCSDS_V1,
            .packetType = asn1Sccpus_TM,
            .secondaryHeaderFlag = FALSE,
            .apid = 0,
            .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
            .sequenceCount = 0
        },
        .step = 0,
        .failure = {
            .code = 0,
            .info = {
                .subcode = -2147483648LL,
                .data = -2147483648LL,
                .address = 0
            }
        }
    }}
    }
};
}
#endif

 
flag asn1SccPusTmHeaderData_IsConstraintValid(const asn1SccPusTmHeaderData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusTmHeader_IsConstraintValid(&pVal->header, pErrCode);
	if (ret) {
	    ret = asn1SccPusTmSourceData_IsConstraintValid(&pVal->data, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTmHeaderData_Encode(const asn1SccPusTmHeaderData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTmHeaderData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode header */
	    ret = asn1SccPusTmHeader_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusTmSourceData_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTmHeaderData_Decode(asn1SccPusTmHeaderData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode header */
	ret = asn1SccPusTmHeader_Decode(&pVal->header, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccPusTmSourceData_Decode(&pVal->data, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTmHeaderData_ACN_Encode(const asn1SccPusTmHeaderData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTmHeaderData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode header */
	    ret = asn1SccPusTmHeader_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusTmSourceData_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTmHeaderData_ACN_Decode(asn1SccPusTmHeaderData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode header */
    ret = asn1SccPusTmHeader_ACN_Decode(&pVal->header, pBitStrm, pErrCode);
    if (ret) {
        /*Decode data */
        ret = asn1SccPusTmSourceData_ACN_Decode(&pVal->data, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketDataReduced_Initialize(asn1SccPusPacketDataReduced* pVal)
{
    *pVal = (asn1SccPusPacketDataReduced) {
    .kind = PusPacketDataReduced_tmData_PRESENT,
    .u = { .tmData = {
    .header = {
        .pusVersion = asn1Sccpus_V0,
        .timeRefStatus = 0,
        .serviceId = 0,
        .subtype = 0,
        .msgTypeCount = 0,
        .destination = 0,
        .time = {
            .tv_sec = LLONG_MIN,
            .tv_nsec = LLONG_MIN
        }
    },
    .data = {
        .kind = st_1_X_PRESENT,
        .u = { .st_1_X = {
        .request = {
            .packetVersion = asn1Sccpus_CCSDS_V1,
            .packetType = asn1Sccpus_TM,
            .secondaryHeaderFlag = FALSE,
            .apid = 0,
            .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
            .sequenceCount = 0
        },
        .step = 0,
        .failure = {
            .code = 0,
            .info = {
                .subcode = -2147483648LL,
                .data = -2147483648LL,
                .address = 0
            }
        }
    }}
    }
}}
};
}
#endif

 
flag asn1SccPusPacketDataReduced_IsConstraintValid(const asn1SccPusPacketDataReduced* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case PusPacketDataReduced_tmData_PRESENT :
	        ret = asn1SccPusTmHeaderData_IsConstraintValid(&pVal->u.tmData, pErrCode);
	        break;
	    case PusPacketDataReduced_tmDataNoHeader_PRESENT :
	        ret = asn1SccPusTmSourceData_IsConstraintValid(&pVal->u.tmDataNoHeader, pErrCode);
	        break;
	    case PusPacketDataReduced_tcData_PRESENT :
	        ret = asn1SccPusPacketDataReduced_tcData_IsConstraintValid(&pVal->u.tcData, pErrCode);
	        break;
	    case PusPacketDataReduced_tcDataNoHeader_PRESENT :
	        ret = asn1SccPusTcApplicationDataReduced_IsConstraintValid(&pVal->u.tcDataNoHeader, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306379;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag asn1SccPusPacketDataReduced_Encode(const asn1SccPusPacketDataReduced* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketDataReduced_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusPacketDataReduced_tmData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = asn1SccPusTmHeaderData_Encode(&pVal->u.tmData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketDataReduced_tmDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = asn1SccPusTmSourceData_Encode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketDataReduced_tcData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = asn1SccPusPacketDataReduced_tcData_Encode(&pVal->u.tcData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketDataReduced_tcDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = asn1SccPusTcApplicationDataReduced_Encode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306380;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusPacketDataReduced_Decode(asn1SccPusPacketDataReduced* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 3);
	*pErrCode = ret ? 0 : 268435529;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = PusPacketDataReduced_tmData_PRESENT;
	    	ret = asn1SccPusTmHeaderData_Decode(&pVal->u.tmData, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PusPacketDataReduced_tmDataNoHeader_PRESENT;
	    	ret = asn1SccPusTmSourceData_Decode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = PusPacketDataReduced_tcData_PRESENT;
	    	ret = asn1SccPusPacketDataReduced_tcData_Decode(&pVal->u.tcData, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = PusPacketDataReduced_tcDataNoHeader_PRESENT;
	    	ret = asn1SccPusTcApplicationDataReduced_Decode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306381;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusPacketDataReduced_ACN_Encode(const asn1SccPusPacketDataReduced* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacketDataReduced_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusPacketDataReduced_tmData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = asn1SccPusTmHeaderData_ACN_Encode(&pVal->u.tmData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketDataReduced_tmDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = asn1SccPusTmSourceData_ACN_Encode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketDataReduced_tcData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = asn1SccPusPacketDataReduced_tcData_ACN_Encode(&pVal->u.tcData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketDataReduced_tcDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = asn1SccPusTcApplicationDataReduced_ACN_Encode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306382;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusPacketDataReduced_ACN_Decode(asn1SccPusPacketDataReduced* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 3);
    *pErrCode = ret ? 0 : 268435530;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = PusPacketDataReduced_tmData_PRESENT;
        	ret = asn1SccPusTmHeaderData_ACN_Decode(&pVal->u.tmData, pBitStrm, pErrCode);
        	break;
        case 1:
        	pVal->kind = PusPacketDataReduced_tmDataNoHeader_PRESENT;
        	ret = asn1SccPusTmSourceData_ACN_Decode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode);
        	break;
        case 2:
        	pVal->kind = PusPacketDataReduced_tcData_PRESENT;
        	ret = asn1SccPusPacketDataReduced_tcData_ACN_Decode(&pVal->u.tcData, pBitStrm, pErrCode);
        	break;
        case 3:
        	pVal->kind = PusPacketDataReduced_tcDataNoHeader_PRESENT;
        	ret = asn1SccPusTcApplicationDataReduced_ACN_Decode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306383;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketReduced_Initialize(asn1SccPusPacketReduced* pVal)
{
    *pVal = (asn1SccPusPacketReduced) {
    .packetVersion = asn1Sccpus_CCSDS_V1,
    .packetType = asn1Sccpus_TM,
    .secondaryHeaderFlag = FALSE,
    .apid = 0,
    .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
    .sequenceCount = 0,
    .dataLength = 0,
    .data = {
        .kind = PusPacketDataReduced_tmData_PRESENT,
        .u = { .tmData = {
        .header = {
            .pusVersion = asn1Sccpus_V0,
            .timeRefStatus = 0,
            .serviceId = 0,
            .subtype = 0,
            .msgTypeCount = 0,
            .destination = 0,
            .time = {
                .tv_sec = LLONG_MIN,
                .tv_nsec = LLONG_MIN
            }
        },
        .data = {
            .kind = st_1_X_PRESENT,
            .u = { .st_1_X = {
            .request = {
                .packetVersion = asn1Sccpus_CCSDS_V1,
                .packetType = asn1Sccpus_TM,
                .secondaryHeaderFlag = FALSE,
                .apid = 0,
                .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
                .sequenceCount = 0
            },
            .step = 0,
            .failure = {
                .code = 0,
                .info = {
                    .subcode = -2147483648LL,
                    .data = -2147483648LL,
                    .address = 0
                }
            }
        }}
        }
    }}
    }
};
}
#endif

 
flag asn1SccPusPacketReduced_IsConstraintValid(const asn1SccPusPacketReduced* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusPacketVersion_IsConstraintValid(&pVal->packetVersion, pErrCode);
	if (ret) {
	    ret = asn1SccPusPacketType_IsConstraintValid(&pVal->packetType, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSecondaryHeaderFlag_IsConstraintValid(&pVal->secondaryHeaderFlag, pErrCode);
	        if (ret) {
	            ret = asn1SccPusApid_IsConstraintValid(&pVal->apid, pErrCode);
	            if (ret) {
	                ret = asn1SccPusSequenceFlags_IsConstraintValid(&pVal->sequenceFlags, pErrCode);
	                if (ret) {
	                    ret = asn1SccPusSequenceCount_IsConstraintValid(&pVal->sequenceCount, pErrCode);
	                    if (ret) {
	                        ret = asn1SccPusPacketDataLength_IsConstraintValid(&pVal->dataLength, pErrCode);
	                        if (ret) {
	                            ret = asn1SccPusPacketDataReduced_IsConstraintValid(&pVal->data, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccPusPacketReduced_Encode(const asn1SccPusPacketReduced* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketReduced_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetVersion */
	    ret = asn1SccPusPacketVersion_Encode(&pVal->packetVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetType */
	        ret = asn1SccPusPacketType_Encode(&pVal->packetType, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode secondaryHeaderFlag */
	            ret = asn1SccPusSecondaryHeaderFlag_Encode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode apid */
	                ret = asn1SccPusApid_Encode(&pVal->apid, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequenceFlags */
	                    ret = asn1SccPusSequenceFlags_Encode(&pVal->sequenceFlags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequenceCount */
	                        ret = asn1SccPusSequenceCount_Encode(&pVal->sequenceCount, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode dataLength */
	                            ret = asn1SccPusPacketDataLength_Encode(&pVal->dataLength, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                ret = asn1SccPusPacketDataReduced_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	                            
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusPacketReduced_Decode(asn1SccPusPacketReduced* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode packetVersion */
	ret = asn1SccPusPacketVersion_Decode(&pVal->packetVersion, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode packetType */
	    ret = asn1SccPusPacketType_Decode(&pVal->packetType, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode secondaryHeaderFlag */
	        ret = asn1SccPusSecondaryHeaderFlag_Decode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode apid */
	            ret = asn1SccPusApid_Decode(&pVal->apid, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode sequenceFlags */
	                ret = asn1SccPusSequenceFlags_Decode(&pVal->sequenceFlags, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode sequenceCount */
	                    ret = asn1SccPusSequenceCount_Decode(&pVal->sequenceCount, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode dataLength */
	                        ret = asn1SccPusPacketDataLength_Decode(&pVal->dataLength, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            ret = asn1SccPusPacketDataReduced_Decode(&pVal->data, pBitStrm, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag asn1SccPusPacketReduced_ACN_Encode(const asn1SccPusPacketReduced* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacketReduced_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetVersion */
	    ret = asn1SccPusPacketVersion_ACN_Encode(&pVal->packetVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetType */
	        ret = asn1SccPusPacketType_ACN_Encode(&pVal->packetType, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode secondaryHeaderFlag */
	            ret = asn1SccPusSecondaryHeaderFlag_ACN_Encode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode apid */
	                ret = asn1SccPusApid_ACN_Encode(&pVal->apid, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequenceFlags */
	                    ret = asn1SccPusSequenceFlags_ACN_Encode(&pVal->sequenceFlags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequenceCount */
	                        ret = asn1SccPusSequenceCount_ACN_Encode(&pVal->sequenceCount, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode dataLength */
	                            ret = asn1SccPusPacketDataLength_ACN_Encode(&pVal->dataLength, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                ret = asn1SccPusPacketDataReduced_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusPacketReduced_ACN_Decode(asn1SccPusPacketReduced* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode packetVersion */
    ret = asn1SccPusPacketVersion_ACN_Decode(&pVal->packetVersion, pBitStrm, pErrCode);
    if (ret) {
        /*Decode packetType */
        ret = asn1SccPusPacketType_ACN_Decode(&pVal->packetType, pBitStrm, pErrCode);
        if (ret) {
            /*Decode secondaryHeaderFlag */
            ret = asn1SccPusSecondaryHeaderFlag_ACN_Decode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode);
            if (ret) {
                /*Decode apid */
                ret = asn1SccPusApid_ACN_Decode(&pVal->apid, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode sequenceFlags */
                    ret = asn1SccPusSequenceFlags_ACN_Decode(&pVal->sequenceFlags, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode sequenceCount */
                        ret = asn1SccPusSequenceCount_ACN_Decode(&pVal->sequenceCount, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode dataLength */
                            ret = asn1SccPusPacketDataLength_ACN_Decode(&pVal->dataLength, pBitStrm, pErrCode);
                            if (ret) {
                                /*Decode data */
                                ret = asn1SccPusPacketDataReduced_ACN_Decode(&pVal->data, pBitStrm, pErrCode);

                            }

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_19_1_Data_Initialize(asn1SccPusTC_19_1_Data* pVal)
{
    *pVal = (asn1SccPusTC_19_1_Data) {
    .eventId = 0,
    .packetReduced = {
        .packetVersion = asn1Sccpus_CCSDS_V1,
        .packetType = asn1Sccpus_TM,
        .secondaryHeaderFlag = FALSE,
        .apid = 0,
        .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
        .sequenceCount = 0,
        .dataLength = 0,
        .data = {
            .kind = PusPacketDataReduced_tmData_PRESENT,
            .u = { .tmData = {
            .header = {
                .pusVersion = asn1Sccpus_V0,
                .timeRefStatus = 0,
                .serviceId = 0,
                .subtype = 0,
                .msgTypeCount = 0,
                .destination = 0,
                .time = {
                    .tv_sec = LLONG_MIN,
                    .tv_nsec = LLONG_MIN
                }
            },
            .data = {
                .kind = st_1_X_PRESENT,
                .u = { .st_1_X = {
                .request = {
                    .packetVersion = asn1Sccpus_CCSDS_V1,
                    .packetType = asn1Sccpus_TM,
                    .secondaryHeaderFlag = FALSE,
                    .apid = 0,
                    .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
                    .sequenceCount = 0
                },
                .step = 0,
                .failure = {
                    .code = 0,
                    .info = {
                        .subcode = -2147483648LL,
                        .data = -2147483648LL,
                        .address = 0
                    }
                }
            }}
            }
        }}
        }
    }
};
}
#endif

 
flag asn1SccPusTC_19_1_Data_IsConstraintValid(const asn1SccPusTC_19_1_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusSt05EventId_IsConstraintValid(&pVal->eventId, pErrCode);
	if (ret) {
	    ret = asn1SccPusPacketReduced_IsConstraintValid(&pVal->packetReduced, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTC_19_1_Data_Encode(const asn1SccPusTC_19_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTC_19_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode eventId */
	    ret = asn1SccPusSt05EventId_Encode(&pVal->eventId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetReduced */
	        ret = asn1SccPusPacketReduced_Encode(&pVal->packetReduced, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTC_19_1_Data_Decode(asn1SccPusTC_19_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode eventId */
	ret = asn1SccPusSt05EventId_Decode(&pVal->eventId, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode packetReduced */
	    ret = asn1SccPusPacketReduced_Decode(&pVal->packetReduced, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTC_19_1_Data_ACN_Encode(const asn1SccPusTC_19_1_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTC_19_1_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode eventId */
	    ret = asn1SccPusSt05EventId_ACN_Encode(&pVal->eventId, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetReduced */
	        ret = asn1SccPusPacketReduced_ACN_Encode(&pVal->packetReduced, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTC_19_1_Data_ACN_Decode(asn1SccPusTC_19_1_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode eventId */
    ret = asn1SccPusSt05EventId_ACN_Decode(&pVal->eventId, pBitStrm, pErrCode);
    if (ret) {
        /*Decode packetReduced */
        ret = asn1SccPusPacketReduced_ACN_Decode(&pVal->packetReduced, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTcScheduledActivity_Initialize(asn1SccPusTcScheduledActivity* pVal)
{
    *pVal = (asn1SccPusTcScheduledActivity) {
    .time = {
        .tv_sec = LLONG_MIN,
        .tv_nsec = LLONG_MIN
    },
    .packetReduced = {
        .packetVersion = asn1Sccpus_CCSDS_V1,
        .packetType = asn1Sccpus_TM,
        .secondaryHeaderFlag = FALSE,
        .apid = 0,
        .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
        .sequenceCount = 0,
        .dataLength = 0,
        .data = {
            .kind = PusPacketDataReduced_tmData_PRESENT,
            .u = { .tmData = {
            .header = {
                .pusVersion = asn1Sccpus_V0,
                .timeRefStatus = 0,
                .serviceId = 0,
                .subtype = 0,
                .msgTypeCount = 0,
                .destination = 0,
                .time = {
                    .tv_sec = LLONG_MIN,
                    .tv_nsec = LLONG_MIN
                }
            },
            .data = {
                .kind = st_1_X_PRESENT,
                .u = { .st_1_X = {
                .request = {
                    .packetVersion = asn1Sccpus_CCSDS_V1,
                    .packetType = asn1Sccpus_TM,
                    .secondaryHeaderFlag = FALSE,
                    .apid = 0,
                    .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
                    .sequenceCount = 0
                },
                .step = 0,
                .failure = {
                    .code = 0,
                    .info = {
                        .subcode = -2147483648LL,
                        .data = -2147483648LL,
                        .address = 0
                    }
                }
            }}
            }
        }}
        }
    }
};
}
#endif

 
flag asn1SccPusTcScheduledActivity_IsConstraintValid(const asn1SccPusTcScheduledActivity* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusTime_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccPusPacketReduced_IsConstraintValid(&pVal->packetReduced, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusTcScheduledActivity_Encode(const asn1SccPusTcScheduledActivity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTcScheduledActivity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccPusTime_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetReduced */
	        ret = asn1SccPusPacketReduced_Encode(&pVal->packetReduced, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusTcScheduledActivity_Decode(asn1SccPusTcScheduledActivity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccPusTime_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode packetReduced */
	    ret = asn1SccPusPacketReduced_Decode(&pVal->packetReduced, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusTcScheduledActivity_ACN_Encode(const asn1SccPusTcScheduledActivity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTcScheduledActivity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccPusTime_ACN_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetReduced */
	        ret = asn1SccPusPacketReduced_ACN_Encode(&pVal->packetReduced, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusTcScheduledActivity_ACN_Decode(asn1SccPusTcScheduledActivity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode time */
    ret = asn1SccPusTime_ACN_Decode(&pVal->time, pBitStrm, pErrCode);
    if (ret) {
        /*Decode packetReduced */
        ret = asn1SccPusPacketReduced_ACN_Decode(&pVal->packetReduced, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTC_11_4_Data_Initialize(asn1SccPusTC_11_4_Data* pVal)
{
    *pVal = (asn1SccPusTC_11_4_Data) {    .nCount = 1,    .arr = 
    {
        {
            .time = {
                .tv_sec = LLONG_MIN,
                .tv_nsec = LLONG_MIN
            },
            .packetReduced = {
                .packetVersion = asn1Sccpus_CCSDS_V1,
                .packetType = asn1Sccpus_TM,
                .secondaryHeaderFlag = FALSE,
                .apid = 0,
                .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
                .sequenceCount = 0,
                .dataLength = 0,
                .data = {
                    .kind = PusPacketDataReduced_tmData_PRESENT,
                    .u = { .tmData = {
                    .header = {
                        .pusVersion = asn1Sccpus_V0,
                        .timeRefStatus = 0,
                        .serviceId = 0,
                        .subtype = 0,
                        .msgTypeCount = 0,
                        .destination = 0,
                        .time = {
                            .tv_sec = LLONG_MIN,
                            .tv_nsec = LLONG_MIN
                        }
                    },
                    .data = {
                        .kind = st_1_X_PRESENT,
                        .u = { .st_1_X = {
                        .request = {
                            .packetVersion = asn1Sccpus_CCSDS_V1,
                            .packetType = asn1Sccpus_TM,
                            .secondaryHeaderFlag = FALSE,
                            .apid = 0,
                            .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
                            .sequenceCount = 0
                        },
                        .step = 0,
                        .failure = {
                            .code = 0,
                            .info = {
                                .subcode = -2147483648LL,
                                .data = -2147483648LL,
                                .address = 0
                            }
                        }
                    }}
                    }
                }}
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccPusTC_11_4_Data_IsConstraintValid(const asn1SccPusTC_11_4_Data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)pus_ST11_MAX_SCHEDULED_ACTIVITIES);
	*pErrCode = ret ? 0 : ERR_asn1SccPusTC_11_4_Data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccPusTcScheduledActivity_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccPusTC_11_4_Data_Encode(const asn1SccPusTC_11_4_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccPusTC_11_4_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 5);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccPusTcScheduledActivity_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccPusTC_11_4_Data_Decode(asn1SccPusTC_11_4_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 5);
	*pErrCode = ret ? 0 : 268435531;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccPusTcScheduledActivity_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag asn1SccPusTC_11_4_Data_ACN_Encode(const asn1SccPusTC_11_4_Data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? asn1SccPusTC_11_4_Data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 5);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccPusTcScheduledActivity_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccPusTC_11_4_Data_ACN_Decode(asn1SccPusTC_11_4_Data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    asn1SccSint nCount;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 5);
    *pErrCode = ret ? 0 : 268435532;
    pVal->nCount = (long)nCount;
    	
    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
    {
    	ret = asn1SccPusTcScheduledActivity_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusTcApplicationData_Initialize(asn1SccPusTcApplicationData* pVal)
{
    *pVal = (asn1SccPusTcApplicationData) {
    .kind = PusTcApplicationData_st_8_1_PRESENT,
    .u = { .st_8_1 = {
    .functionId = 0
}}
};
}
#endif

 
flag asn1SccPusTcApplicationData_IsConstraintValid(const asn1SccPusTcApplicationData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case PusTcApplicationData_st_8_1_PRESENT :
	        ret = asn1SccPusTC_8_1_Data_IsConstraintValid(&pVal->u.st_8_1, pErrCode);
	        break;
	    case PusTcApplicationData_st_9_1_PRESENT :
	        ret = asn1SccPusTC_9_1_Data_IsConstraintValid(&pVal->u.st_9_1, pErrCode);
	        break;
	    case PusTcApplicationData_st_12_1_2_PRESENT :
	        ret = asn1SccPusTC_12_1_2_Data_IsConstraintValid(&pVal->u.st_12_1_2, pErrCode);
	        break;
	    case PusTcApplicationData_st_18_1_PRESENT :
	        ret = asn1SccPusTC_18_1_Data_IsConstraintValid(&pVal->u.st_18_1, pErrCode);
	        break;
	    case PusTcApplicationData_st_18_2_6_12_PRESENT :
	        ret = asn1SccPusTC_18_2_6_12_Data_IsConstraintValid(&pVal->u.st_18_2_6_12, pErrCode);
	        break;
	    case PusTcApplicationData_st_18_3_PRESENT :
	        ret = asn1SccPusTC_18_3_Data_IsConstraintValid(&pVal->u.st_18_3, pErrCode);
	        break;
	    case PusTcApplicationData_st_18_4_5_PRESENT :
	        ret = asn1SccPusTC_18_4_5_Data_IsConstraintValid(&pVal->u.st_18_4_5, pErrCode);
	        break;
	    case PusTcApplicationData_st_18_13_PRESENT :
	        ret = asn1SccPusTC_18_13_Data_IsConstraintValid(&pVal->u.st_18_13, pErrCode);
	        break;
	    case PusTcApplicationData_st_19_X_PRESENT :
	        ret = asn1SccPusTC_19_X_Data_IsConstraintValid(&pVal->u.st_19_X, pErrCode);
	        break;
	    case PusTcApplicationData_st_20_X_PRESENT :
	        ret = asn1SccPusTC_TM_20_X_Data_IsConstraintValid(&pVal->u.st_20_X, pErrCode);
	        break;
	    case PusTcApplicationData_st_23_1_PRESENT :
	        ret = asn1SccPusTC_TM_23_1_4_Data_IsConstraintValid(&pVal->u.st_23_1, pErrCode);
	        break;
	    case PusTcApplicationData_st_23_2_3_PRESENT :
	        ret = asn1SccPusTC_23_2_3_Data_IsConstraintValid(&pVal->u.st_23_2_3, pErrCode);
	        break;
	    case PusTcApplicationData_st_23_14_PRESENT :
	        ret = asn1SccPusTC_23_14_Data_IsConstraintValid(&pVal->u.st_23_14, pErrCode);
	        break;
	    case st_11_4_PRESENT :
	        ret = asn1SccPusTC_11_4_Data_IsConstraintValid(&pVal->u.st_11_4, pErrCode);
	        break;
	    case st_19_1_PRESENT :
	        ret = asn1SccPusTC_19_1_Data_IsConstraintValid(&pVal->u.st_19_1, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306384;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag asn1SccPusTcApplicationData_Encode(const asn1SccPusTcApplicationData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusTcApplicationData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusTcApplicationData_st_8_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 14);
	    	ret = asn1SccPusTC_8_1_Data_Encode(&pVal->u.st_8_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_9_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 14);
	    	ret = asn1SccPusTC_9_1_Data_Encode(&pVal->u.st_9_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_12_1_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 14);
	    	ret = asn1SccPusTC_12_1_2_Data_Encode(&pVal->u.st_12_1_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 14);
	    	ret = asn1SccPusTC_18_1_Data_Encode(&pVal->u.st_18_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_2_6_12_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 14);
	    	ret = asn1SccPusTC_18_2_6_12_Data_Encode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 14);
	    	ret = asn1SccPusTC_18_3_Data_Encode(&pVal->u.st_18_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_4_5_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 14);
	    	ret = asn1SccPusTC_18_4_5_Data_Encode(&pVal->u.st_18_4_5, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_13_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 14);
	    	ret = asn1SccPusTC_18_13_Data_Encode(&pVal->u.st_18_13, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_19_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 14);
	    	ret = asn1SccPusTC_19_X_Data_Encode(&pVal->u.st_19_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_20_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 14);
	    	ret = asn1SccPusTC_TM_20_X_Data_Encode(&pVal->u.st_20_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_23_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 14);
	    	ret = asn1SccPusTC_TM_23_1_4_Data_Encode(&pVal->u.st_23_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_23_2_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 14);
	    	ret = asn1SccPusTC_23_2_3_Data_Encode(&pVal->u.st_23_2_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_23_14_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 14);
	    	ret = asn1SccPusTC_23_14_Data_Encode(&pVal->u.st_23_14, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_11_4_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 14);
	    	ret = asn1SccPusTC_11_4_Data_Encode(&pVal->u.st_11_4, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_19_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 14);
	    	ret = asn1SccPusTC_19_1_Data_Encode(&pVal->u.st_19_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306385;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusTcApplicationData_Decode(asn1SccPusTcApplicationData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 14);
	*pErrCode = ret ? 0 : 268435533;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = PusTcApplicationData_st_8_1_PRESENT;
	    	ret = asn1SccPusTC_8_1_Data_Decode(&pVal->u.st_8_1, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PusTcApplicationData_st_9_1_PRESENT;
	    	ret = asn1SccPusTC_9_1_Data_Decode(&pVal->u.st_9_1, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = PusTcApplicationData_st_12_1_2_PRESENT;
	    	ret = asn1SccPusTC_12_1_2_Data_Decode(&pVal->u.st_12_1_2, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = PusTcApplicationData_st_18_1_PRESENT;
	    	ret = asn1SccPusTC_18_1_Data_Decode(&pVal->u.st_18_1, pBitStrm, pErrCode);
	    	break;
	    case 4:
	    	pVal->kind = PusTcApplicationData_st_18_2_6_12_PRESENT;
	    	ret = asn1SccPusTC_18_2_6_12_Data_Decode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode);
	    	break;
	    case 5:
	    	pVal->kind = PusTcApplicationData_st_18_3_PRESENT;
	    	ret = asn1SccPusTC_18_3_Data_Decode(&pVal->u.st_18_3, pBitStrm, pErrCode);
	    	break;
	    case 6:
	    	pVal->kind = PusTcApplicationData_st_18_4_5_PRESENT;
	    	ret = asn1SccPusTC_18_4_5_Data_Decode(&pVal->u.st_18_4_5, pBitStrm, pErrCode);
	    	break;
	    case 7:
	    	pVal->kind = PusTcApplicationData_st_18_13_PRESENT;
	    	ret = asn1SccPusTC_18_13_Data_Decode(&pVal->u.st_18_13, pBitStrm, pErrCode);
	    	break;
	    case 8:
	    	pVal->kind = PusTcApplicationData_st_19_X_PRESENT;
	    	ret = asn1SccPusTC_19_X_Data_Decode(&pVal->u.st_19_X, pBitStrm, pErrCode);
	    	break;
	    case 9:
	    	pVal->kind = PusTcApplicationData_st_20_X_PRESENT;
	    	ret = asn1SccPusTC_TM_20_X_Data_Decode(&pVal->u.st_20_X, pBitStrm, pErrCode);
	    	break;
	    case 10:
	    	pVal->kind = PusTcApplicationData_st_23_1_PRESENT;
	    	ret = asn1SccPusTC_TM_23_1_4_Data_Decode(&pVal->u.st_23_1, pBitStrm, pErrCode);
	    	break;
	    case 11:
	    	pVal->kind = PusTcApplicationData_st_23_2_3_PRESENT;
	    	ret = asn1SccPusTC_23_2_3_Data_Decode(&pVal->u.st_23_2_3, pBitStrm, pErrCode);
	    	break;
	    case 12:
	    	pVal->kind = PusTcApplicationData_st_23_14_PRESENT;
	    	ret = asn1SccPusTC_23_14_Data_Decode(&pVal->u.st_23_14, pBitStrm, pErrCode);
	    	break;
	    case 13:
	    	pVal->kind = st_11_4_PRESENT;
	    	ret = asn1SccPusTC_11_4_Data_Decode(&pVal->u.st_11_4, pBitStrm, pErrCode);
	    	break;
	    case 14:
	    	pVal->kind = st_19_1_PRESENT;
	    	ret = asn1SccPusTC_19_1_Data_Decode(&pVal->u.st_19_1, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306386;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusTcApplicationData_ACN_Encode(const asn1SccPusTcApplicationData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusTcApplicationData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusTcApplicationData_st_8_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 14);
	    	ret = asn1SccPusTC_8_1_Data_ACN_Encode(&pVal->u.st_8_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_9_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 14);
	    	ret = asn1SccPusTC_9_1_Data_ACN_Encode(&pVal->u.st_9_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_12_1_2_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 14);
	    	ret = asn1SccPusTC_12_1_2_Data_ACN_Encode(&pVal->u.st_12_1_2, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 14);
	    	ret = asn1SccPusTC_18_1_Data_ACN_Encode(&pVal->u.st_18_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_2_6_12_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 14);
	    	ret = asn1SccPusTC_18_2_6_12_Data_ACN_Encode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 14);
	    	ret = asn1SccPusTC_18_3_Data_ACN_Encode(&pVal->u.st_18_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_4_5_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 14);
	    	ret = asn1SccPusTC_18_4_5_Data_ACN_Encode(&pVal->u.st_18_4_5, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_18_13_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 14);
	    	ret = asn1SccPusTC_18_13_Data_ACN_Encode(&pVal->u.st_18_13, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_19_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 14);
	    	ret = asn1SccPusTC_19_X_Data_ACN_Encode(&pVal->u.st_19_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_20_X_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 14);
	    	ret = asn1SccPusTC_TM_20_X_Data_ACN_Encode(&pVal->u.st_20_X, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_23_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 14);
	    	ret = asn1SccPusTC_TM_23_1_4_Data_ACN_Encode(&pVal->u.st_23_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_23_2_3_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 14);
	    	ret = asn1SccPusTC_23_2_3_Data_ACN_Encode(&pVal->u.st_23_2_3, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusTcApplicationData_st_23_14_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 14);
	    	ret = asn1SccPusTC_23_14_Data_ACN_Encode(&pVal->u.st_23_14, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_11_4_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 14);
	    	ret = asn1SccPusTC_11_4_Data_ACN_Encode(&pVal->u.st_11_4, pBitStrm, pErrCode, FALSE);
	    	break;
	    case st_19_1_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 14);
	    	ret = asn1SccPusTC_19_1_Data_ACN_Encode(&pVal->u.st_19_1, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306387;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusTcApplicationData_ACN_Decode(asn1SccPusTcApplicationData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 14);
    *pErrCode = ret ? 0 : 268435534;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = PusTcApplicationData_st_8_1_PRESENT;
        	ret = asn1SccPusTC_8_1_Data_ACN_Decode(&pVal->u.st_8_1, pBitStrm, pErrCode);
        	break;
        case 1:
        	pVal->kind = PusTcApplicationData_st_9_1_PRESENT;
        	ret = asn1SccPusTC_9_1_Data_ACN_Decode(&pVal->u.st_9_1, pBitStrm, pErrCode);
        	break;
        case 2:
        	pVal->kind = PusTcApplicationData_st_12_1_2_PRESENT;
        	ret = asn1SccPusTC_12_1_2_Data_ACN_Decode(&pVal->u.st_12_1_2, pBitStrm, pErrCode);
        	break;
        case 3:
        	pVal->kind = PusTcApplicationData_st_18_1_PRESENT;
        	ret = asn1SccPusTC_18_1_Data_ACN_Decode(&pVal->u.st_18_1, pBitStrm, pErrCode);
        	break;
        case 4:
        	pVal->kind = PusTcApplicationData_st_18_2_6_12_PRESENT;
        	ret = asn1SccPusTC_18_2_6_12_Data_ACN_Decode(&pVal->u.st_18_2_6_12, pBitStrm, pErrCode);
        	break;
        case 5:
        	pVal->kind = PusTcApplicationData_st_18_3_PRESENT;
        	ret = asn1SccPusTC_18_3_Data_ACN_Decode(&pVal->u.st_18_3, pBitStrm, pErrCode);
        	break;
        case 6:
        	pVal->kind = PusTcApplicationData_st_18_4_5_PRESENT;
        	ret = asn1SccPusTC_18_4_5_Data_ACN_Decode(&pVal->u.st_18_4_5, pBitStrm, pErrCode);
        	break;
        case 7:
        	pVal->kind = PusTcApplicationData_st_18_13_PRESENT;
        	ret = asn1SccPusTC_18_13_Data_ACN_Decode(&pVal->u.st_18_13, pBitStrm, pErrCode);
        	break;
        case 8:
        	pVal->kind = PusTcApplicationData_st_19_X_PRESENT;
        	ret = asn1SccPusTC_19_X_Data_ACN_Decode(&pVal->u.st_19_X, pBitStrm, pErrCode);
        	break;
        case 9:
        	pVal->kind = PusTcApplicationData_st_20_X_PRESENT;
        	ret = asn1SccPusTC_TM_20_X_Data_ACN_Decode(&pVal->u.st_20_X, pBitStrm, pErrCode);
        	break;
        case 10:
        	pVal->kind = PusTcApplicationData_st_23_1_PRESENT;
        	ret = asn1SccPusTC_TM_23_1_4_Data_ACN_Decode(&pVal->u.st_23_1, pBitStrm, pErrCode);
        	break;
        case 11:
        	pVal->kind = PusTcApplicationData_st_23_2_3_PRESENT;
        	ret = asn1SccPusTC_23_2_3_Data_ACN_Decode(&pVal->u.st_23_2_3, pBitStrm, pErrCode);
        	break;
        case 12:
        	pVal->kind = PusTcApplicationData_st_23_14_PRESENT;
        	ret = asn1SccPusTC_23_14_Data_ACN_Decode(&pVal->u.st_23_14, pBitStrm, pErrCode);
        	break;
        case 13:
        	pVal->kind = st_11_4_PRESENT;
        	ret = asn1SccPusTC_11_4_Data_ACN_Decode(&pVal->u.st_11_4, pBitStrm, pErrCode);
        	break;
        case 14:
        	pVal->kind = st_19_1_PRESENT;
        	ret = asn1SccPusTC_19_1_Data_ACN_Decode(&pVal->u.st_19_1, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306388;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketData_tcData_Initialize(asn1SccPusPacketData_tcData* pVal)
{
    *pVal = (asn1SccPusPacketData_tcData) {
    .header = {
        .pusVersion = asn1Sccpus_V0,
        .ackFlags = {
            .acceptanceReportRequested = FALSE,
            .startReportRequested = FALSE,
            .progressReportRequested = FALSE,
            .completionReportRequested = FALSE
        },
        .serviceId = 0,
        .subtype = 0,
        .source = 0
    },
    .data = {
        .kind = PusTcApplicationData_st_8_1_PRESENT,
        .u = { .st_8_1 = {
        .functionId = 0
    }}
    }
};
}
#endif

 
flag asn1SccPusPacketData_tcData_IsConstraintValid(const asn1SccPusPacketData_tcData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusTcHeader_IsConstraintValid(&pVal->header, pErrCode);
	if (ret) {
	    ret = asn1SccPusTcApplicationData_IsConstraintValid(&pVal->data, pErrCode);
	
	}

	return ret;
}

flag asn1SccPusPacketData_tcData_Encode(const asn1SccPusPacketData_tcData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketData_tcData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode header */
	    ret = asn1SccPusTcHeader_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusTcApplicationData_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccPusPacketData_tcData_Decode(asn1SccPusPacketData_tcData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode header */
	ret = asn1SccPusTcHeader_Decode(&pVal->header, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccPusTcApplicationData_Decode(&pVal->data, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag asn1SccPusPacketData_tcData_ACN_Encode(const asn1SccPusPacketData_tcData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacketData_tcData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode header */
	    ret = asn1SccPusTcHeader_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccPusTcApplicationData_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag asn1SccPusPacketData_tcData_ACN_Decode(asn1SccPusPacketData_tcData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode header */
    ret = asn1SccPusTcHeader_ACN_Decode(&pVal->header, pBitStrm, pErrCode);
    if (ret) {
        /*Decode data */
        ret = asn1SccPusTcApplicationData_ACN_Decode(&pVal->data, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacketData_Initialize(asn1SccPusPacketData* pVal)
{
    *pVal = (asn1SccPusPacketData) {
    .kind = PusPacketData_tmData_PRESENT,
    .u = { .tmData = {
    .header = {
        .pusVersion = asn1Sccpus_V0,
        .timeRefStatus = 0,
        .serviceId = 0,
        .subtype = 0,
        .msgTypeCount = 0,
        .destination = 0,
        .time = {
            .tv_sec = LLONG_MIN,
            .tv_nsec = LLONG_MIN
        }
    },
    .data = {
        .kind = st_1_X_PRESENT,
        .u = { .st_1_X = {
        .request = {
            .packetVersion = asn1Sccpus_CCSDS_V1,
            .packetType = asn1Sccpus_TM,
            .secondaryHeaderFlag = FALSE,
            .apid = 0,
            .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
            .sequenceCount = 0
        },
        .step = 0,
        .failure = {
            .code = 0,
            .info = {
                .subcode = -2147483648LL,
                .data = -2147483648LL,
                .address = 0
            }
        }
    }}
    }
}}
};
}
#endif

 
flag asn1SccPusPacketData_IsConstraintValid(const asn1SccPusPacketData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case PusPacketData_tmData_PRESENT :
	        ret = asn1SccPusTmHeaderData_IsConstraintValid(&pVal->u.tmData, pErrCode);
	        break;
	    case PusPacketData_tmDataNoHeader_PRESENT :
	        ret = asn1SccPusTmSourceData_IsConstraintValid(&pVal->u.tmDataNoHeader, pErrCode);
	        break;
	    case PusPacketData_tcData_PRESENT :
	        ret = asn1SccPusPacketData_tcData_IsConstraintValid(&pVal->u.tcData, pErrCode);
	        break;
	    case PusPacketData_tcDataNoHeader_PRESENT :
	        ret = asn1SccPusTcApplicationData_IsConstraintValid(&pVal->u.tcDataNoHeader, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306389;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag asn1SccPusPacketData_Encode(const asn1SccPusPacketData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacketData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusPacketData_tmData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = asn1SccPusTmHeaderData_Encode(&pVal->u.tmData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketData_tmDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = asn1SccPusTmSourceData_Encode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketData_tcData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = asn1SccPusPacketData_tcData_Encode(&pVal->u.tcData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketData_tcDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = asn1SccPusTcApplicationData_Encode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306390;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusPacketData_Decode(asn1SccPusPacketData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 3);
	*pErrCode = ret ? 0 : 268435535;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = PusPacketData_tmData_PRESENT;
	    	ret = asn1SccPusTmHeaderData_Decode(&pVal->u.tmData, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = PusPacketData_tmDataNoHeader_PRESENT;
	    	ret = asn1SccPusTmSourceData_Decode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = PusPacketData_tcData_PRESENT;
	    	ret = asn1SccPusPacketData_tcData_Decode(&pVal->u.tcData, pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = PusPacketData_tcDataNoHeader_PRESENT;
	    	ret = asn1SccPusTcApplicationData_Decode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306391;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag asn1SccPusPacketData_ACN_Encode(const asn1SccPusPacketData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacketData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case PusPacketData_tmData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = asn1SccPusTmHeaderData_ACN_Encode(&pVal->u.tmData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketData_tmDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = asn1SccPusTmSourceData_ACN_Encode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketData_tcData_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = asn1SccPusPacketData_tcData_ACN_Encode(&pVal->u.tcData, pBitStrm, pErrCode, FALSE);
	    	break;
	    case PusPacketData_tcDataNoHeader_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = asn1SccPusTcApplicationData_ACN_Encode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306392;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccPusPacketData_ACN_Decode(asn1SccPusPacketData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 3);
    *pErrCode = ret ? 0 : 268435536;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = PusPacketData_tmData_PRESENT;
        	ret = asn1SccPusTmHeaderData_ACN_Decode(&pVal->u.tmData, pBitStrm, pErrCode);
        	break;
        case 1:
        	pVal->kind = PusPacketData_tmDataNoHeader_PRESENT;
        	ret = asn1SccPusTmSourceData_ACN_Decode(&pVal->u.tmDataNoHeader, pBitStrm, pErrCode);
        	break;
        case 2:
        	pVal->kind = PusPacketData_tcData_PRESENT;
        	ret = asn1SccPusPacketData_tcData_ACN_Decode(&pVal->u.tcData, pBitStrm, pErrCode);
        	break;
        case 3:
        	pVal->kind = PusPacketData_tcDataNoHeader_PRESENT;
        	ret = asn1SccPusTcApplicationData_ACN_Decode(&pVal->u.tcDataNoHeader, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306393;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPusPacket_Initialize(asn1SccPusPacket* pVal)
{
    *pVal = (asn1SccPusPacket) {
    .packetVersion = asn1Sccpus_CCSDS_V1,
    .packetType = asn1Sccpus_TM,
    .secondaryHeaderFlag = FALSE,
    .apid = 0,
    .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
    .sequenceCount = 0,
    .dataLength = 0,
    .data = {
        .kind = PusPacketData_tmData_PRESENT,
        .u = { .tmData = {
        .header = {
            .pusVersion = asn1Sccpus_V0,
            .timeRefStatus = 0,
            .serviceId = 0,
            .subtype = 0,
            .msgTypeCount = 0,
            .destination = 0,
            .time = {
                .tv_sec = LLONG_MIN,
                .tv_nsec = LLONG_MIN
            }
        },
        .data = {
            .kind = st_1_X_PRESENT,
            .u = { .st_1_X = {
            .request = {
                .packetVersion = asn1Sccpus_CCSDS_V1,
                .packetType = asn1Sccpus_TM,
                .secondaryHeaderFlag = FALSE,
                .apid = 0,
                .sequenceFlags = asn1Sccpus_STANDALONE_PACKET,
                .sequenceCount = 0
            },
            .step = 0,
            .failure = {
                .code = 0,
                .info = {
                    .subcode = -2147483648LL,
                    .data = -2147483648LL,
                    .address = 0
                }
            }
        }}
        }
    }}
    }
};
}
#endif

 
flag asn1SccPusPacket_IsConstraintValid(const asn1SccPusPacket* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPusPacketVersion_IsConstraintValid(&pVal->packetVersion, pErrCode);
	if (ret) {
	    ret = asn1SccPusPacketType_IsConstraintValid(&pVal->packetType, pErrCode);
	    if (ret) {
	        ret = asn1SccPusSecondaryHeaderFlag_IsConstraintValid(&pVal->secondaryHeaderFlag, pErrCode);
	        if (ret) {
	            ret = asn1SccPusApid_IsConstraintValid(&pVal->apid, pErrCode);
	            if (ret) {
	                ret = asn1SccPusSequenceFlags_IsConstraintValid(&pVal->sequenceFlags, pErrCode);
	                if (ret) {
	                    ret = asn1SccPusSequenceCount_IsConstraintValid(&pVal->sequenceCount, pErrCode);
	                    if (ret) {
	                        ret = asn1SccPusPacketDataLength_IsConstraintValid(&pVal->dataLength, pErrCode);
	                        if (ret) {
	                            ret = asn1SccPusPacketData_IsConstraintValid(&pVal->data, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccPusPacket_Encode(const asn1SccPusPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccPusPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetVersion */
	    ret = asn1SccPusPacketVersion_Encode(&pVal->packetVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetType */
	        ret = asn1SccPusPacketType_Encode(&pVal->packetType, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode secondaryHeaderFlag */
	            ret = asn1SccPusSecondaryHeaderFlag_Encode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode apid */
	                ret = asn1SccPusApid_Encode(&pVal->apid, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequenceFlags */
	                    ret = asn1SccPusSequenceFlags_Encode(&pVal->sequenceFlags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequenceCount */
	                        ret = asn1SccPusSequenceCount_Encode(&pVal->sequenceCount, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode dataLength */
	                            ret = asn1SccPusPacketDataLength_Encode(&pVal->dataLength, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                ret = asn1SccPusPacketData_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	                            
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccPusPacket_Decode(asn1SccPusPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode packetVersion */
	ret = asn1SccPusPacketVersion_Decode(&pVal->packetVersion, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode packetType */
	    ret = asn1SccPusPacketType_Decode(&pVal->packetType, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode secondaryHeaderFlag */
	        ret = asn1SccPusSecondaryHeaderFlag_Decode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode apid */
	            ret = asn1SccPusApid_Decode(&pVal->apid, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode sequenceFlags */
	                ret = asn1SccPusSequenceFlags_Decode(&pVal->sequenceFlags, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode sequenceCount */
	                    ret = asn1SccPusSequenceCount_Decode(&pVal->sequenceCount, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode dataLength */
	                        ret = asn1SccPusPacketDataLength_Decode(&pVal->dataLength, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            ret = asn1SccPusPacketData_Decode(&pVal->data, pBitStrm, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag asn1SccPusPacket_ACN_Encode(const asn1SccPusPacket* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccPusPacket_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode packetVersion */
	    ret = asn1SccPusPacketVersion_ACN_Encode(&pVal->packetVersion, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode packetType */
	        ret = asn1SccPusPacketType_ACN_Encode(&pVal->packetType, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode secondaryHeaderFlag */
	            ret = asn1SccPusSecondaryHeaderFlag_ACN_Encode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode apid */
	                ret = asn1SccPusApid_ACN_Encode(&pVal->apid, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequenceFlags */
	                    ret = asn1SccPusSequenceFlags_ACN_Encode(&pVal->sequenceFlags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequenceCount */
	                        ret = asn1SccPusSequenceCount_ACN_Encode(&pVal->sequenceCount, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode dataLength */
	                            ret = asn1SccPusPacketDataLength_ACN_Encode(&pVal->dataLength, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                ret = asn1SccPusPacketData_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag asn1SccPusPacket_ACN_Decode(asn1SccPusPacket* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode packetVersion */
    ret = asn1SccPusPacketVersion_ACN_Decode(&pVal->packetVersion, pBitStrm, pErrCode);
    if (ret) {
        /*Decode packetType */
        ret = asn1SccPusPacketType_ACN_Decode(&pVal->packetType, pBitStrm, pErrCode);
        if (ret) {
            /*Decode secondaryHeaderFlag */
            ret = asn1SccPusSecondaryHeaderFlag_ACN_Decode(&pVal->secondaryHeaderFlag, pBitStrm, pErrCode);
            if (ret) {
                /*Decode apid */
                ret = asn1SccPusApid_ACN_Decode(&pVal->apid, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode sequenceFlags */
                    ret = asn1SccPusSequenceFlags_ACN_Decode(&pVal->sequenceFlags, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode sequenceCount */
                        ret = asn1SccPusSequenceCount_ACN_Decode(&pVal->sequenceCount, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode dataLength */
                            ret = asn1SccPusPacketDataLength_ACN_Decode(&pVal->dataLength, pBitStrm, pErrCode);
                            if (ret) {
                                /*Decode data */
                                ret = asn1SccPusPacketData_ACN_Decode(&pVal->data, pBitStrm, pErrCode);

                            }

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTASTE_Boolean_Initialize(asn1SccTASTE_Boolean* pVal)
{
    *pVal = (asn1SccTASTE_Boolean) FALSE;
}
#endif

 
flag asn1SccTASTE_Boolean_IsConstraintValid(const asn1SccTASTE_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag asn1SccTASTE_Boolean_Encode(const asn1SccTASTE_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccTASTE_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag asn1SccTASTE_Boolean_Decode(asn1SccTASTE_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435537;

	return ret;
}

flag asn1SccTASTE_Boolean_ACN_Encode(const asn1SccTASTE_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? asn1SccTASTE_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag asn1SccTASTE_Boolean_ACN_Decode(asn1SccTASTE_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435538;
    }
    return ret;
}

const asn1SccPusSt05EventId pus_EVENT_ID_NONE = 0;

const asn1SccPusSt05EventAuxData pus_EVENT_AUXDATA_NONE = {
    .data1 = 0,
    .data2 = 0
};

const asn1SccPusUInt64 pus_EVENT_DATASTORED_NONE = 0;

const asn1SccPusSt03HousekeepingReportId pus_ST03_DEFAULT_HK_REPORT = 0;

const asn1SccPusPacketVersion pus_PACKET_VERSION_CURRENT = asn1Sccpus_CCSDS_V1;

const asn1SccPusApid pus_APID_TIME = 0;

const asn1SccPusApid pus_APID_IDLE = 2047;

const asn1SccPusVersionNumber pus_VERSION_CURRENT = asn1Sccpus_V2;

const asn1SccPusTimeReferenceStatus pus_TIME_REFERENCE_STATUS_NONE = 0;

const asn1SccPusMessageTypeCounter pus_MESSAGE_TYPE_COUNTER_NONE = 0;

const asn1SccPusStepId pus_STEP_NONE = 0;

const asn1SccPusSt01FailureCode pus_ST01_NO_ERROR = 0;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_APID_UNAVAILABLE = 1;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_SERVICE_UNAVAILABLE = 2;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_SUBTYPE_UNAVAILABLE = 3;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_APID_UNKNOWN = 4;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_SERVICE_UNKNOWN = 5;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_SUBTYPE_UNKNOWN = 6;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_WRONG_FORMAT = 7;

const asn1SccPusSt01FailureCode pus_ST01_ERROR_CHECKSUM = 8;

const asn1SccPusUInt32 pus_ST03_MAX_REPORT_LENGTH = 20;

const asn1SccPusUInt32 pus_ST11_MAX_SCHEDULED_ACTIVITIES = 5;

const asn1SccPusUInt32 pus_ST18_SIZE_OBCP_ID = 10;

const asn1SccPusUInt32 pus_ST18_MAX_SIZE_OBCP_CODE = 1000;

const asn1SccPusUInt32 pus_ST18_SIZE_OBCP_CHECKSUM = 16;

const asn1SccPusUInt32 pus_ST23_MAX_SIZE_FILE_PATH = 30;

const asn1SccPusUInt32 pus_ST23_MAX_SIZE_REPOSITORY_PATH = 30;

const asn1SccPusUInt32 pus_ST23_MAX_SIZE_REPOSITORY_DOMAIN = 30;

const asn1SccPusUInt32 pus_ST23_MAX_SIZE_FILE = 1000;

const asn1SccPusServiceType pusService_NONE = 0;

const asn1SccPusServiceType pus_ST01_requestVerification = 1;

const asn1SccPusServiceType pus_ST02_deviceAccess = 2;

const asn1SccPusServiceType pus_ST03_housekeeping = 3;

const asn1SccPusServiceType pus_ST04_parameterStatisticsReporting = 4;

const asn1SccPusServiceType pus_ST05_eventReporting = 5;

const asn1SccPusServiceType pus_ST06_memoryManagement = 6;

const asn1SccPusServiceType pus_ST08_functionManagement = 8;

const asn1SccPusServiceType pus_ST09_timeManagement = 9;

const asn1SccPusServiceType pus_ST11_timeBasedScheduling = 11;

const asn1SccPusServiceType pus_ST12_onBoardMonitoring = 12;

const asn1SccPusServiceType pus_ST13_largePacketTransfer = 13;

const asn1SccPusServiceType pus_ST14_realTimeForwardingControl = 14;

const asn1SccPusServiceType pus_ST15_onBoardStorageAndRetrieval = 15;

const asn1SccPusServiceType pus_ST17_test = 17;

const asn1SccPusServiceType pus_ST18_onBoardControlProcedure = 18;

const asn1SccPusServiceType pus_ST19_eventAction = 19;

const asn1SccPusServiceType pus_ST20_parameterManagement = 20;

const asn1SccPusServiceType pus_ST21_requestSequencing = 21;

const asn1SccPusServiceType pus_ST22_partitionBasedScheduling = 22;

const asn1SccPusServiceType pus_ST23_fileManagement = 23;

const asn1SccPusSubserviceType pusSubtype_NONE = 0;

const asn1SccPusSubserviceType pus_TM_1_1_successfulAcceptance = 1;

const asn1SccPusSubserviceType pus_TM_1_2_failedAcceptance = 2;

const asn1SccPusSubserviceType pus_TM_1_3_successfulStart = 3;

const asn1SccPusSubserviceType pus_TM_1_4_failedStart = 4;

const asn1SccPusSubserviceType pus_TM_1_5_successfulProgress = 5;

const asn1SccPusSubserviceType pus_TM_1_6_failedProgress = 6;

const asn1SccPusSubserviceType pus_TM_1_7_successfulCompletion = 7;

const asn1SccPusSubserviceType pus_TM_1_8_failedCompletion = 8;

const asn1SccPusSubserviceType pus_TM_3_25_housekeepingReport = 25;

const asn1SccPusSubserviceType pus_TM_5_1_eventInformative = 1;

const asn1SccPusSubserviceType pus_TM_5_2_anomalyLowSeverity = 2;

const asn1SccPusSubserviceType pus_TM_5_3_anomalyMediumSeverity = 3;

const asn1SccPusSubserviceType pus_TM_5_4_anomalyHighSeverity = 4;

const asn1SccPusSubserviceType pus_TC_8_1_performFunction = 1;

const asn1SccPusSubserviceType pus_TC_9_1_setTimeReportRate = 1;

const asn1SccPusSubserviceType pus_TM_9_2_cucTimeReport = 2;

const asn1SccPusSubserviceType pus_TC_11_1_enableTimeBasedScheduling = 1;

const asn1SccPusSubserviceType pus_TC_11_2_disableTimeBasedScheduling = 2;

const asn1SccPusSubserviceType pus_TC_11_3_resetTimeBasedSchedule = 3;

const asn1SccPusSubserviceType pus_TC_11_4_insertActivity = 4;

const asn1SccPusSubserviceType pus_TC_12_1_enableParameterMonitoringDefinitions = 1;

const asn1SccPusSubserviceType pus_TC_12_2_disableParameterMonitoringDefinitions = 2;

const asn1SccPusSubserviceType pus_TC_12_15_enableParameterMonitoring = 15;

const asn1SccPusSubserviceType pus_TC_12_16_disableParameterMonitoring = 16;

const asn1SccPusSubserviceType pus_TC_17_1_connectionTest = 1;

const asn1SccPusSubserviceType pus_TM_17_2_connectionTest = 2;

const asn1SccPusSubserviceType pus_TC_18_1_loadObcpDirect = 1;

const asn1SccPusSubserviceType pus_TC_18_2_unloadObcp = 2;

const asn1SccPusSubserviceType pus_TC_18_3_activateObcp = 3;

const asn1SccPusSubserviceType pus_TC_18_4_stopObcp = 4;

const asn1SccPusSubserviceType pus_TC_18_5_suspendObcp = 5;

const asn1SccPusSubserviceType pus_TC_18_6_resumeObcp = 6;

const asn1SccPusSubserviceType pus_TC_18_12_abortObcp = 12;

const asn1SccPusSubserviceType pus_TC_18_13_loadObcpByReference = 13;

const asn1SccPusSubserviceType pus_TC_18_21_startObcpEngine = 21;

const asn1SccPusSubserviceType pus_TC_18_22_stopObcpEngine = 22;

const asn1SccPusSubserviceType pus_TC_19_1_addEventActionDefinitions = 1;

const asn1SccPusSubserviceType pus_TC_19_2_deleteEventActionDefinitions = 2;

const asn1SccPusSubserviceType pus_TC_19_4_enableEventActionDefinitions = 4;

const asn1SccPusSubserviceType pus_TC_19_5_disableEventActionDefinitions = 5;

const asn1SccPusSubserviceType pus_TC_20_1_reportParameterValues = 1;

const asn1SccPusSubserviceType pus_TM_20_2_reportParameterValues = 2;

const asn1SccPusSubserviceType pus_TC_20_3_setParameterValues = 3;

const asn1SccPusSubserviceType pus_TC_23_1_createFile = 1;

const asn1SccPusSubserviceType pus_TC_23_2_deleteFile = 2;

const asn1SccPusSubserviceType pus_TC_23_3_reportFileAttributes = 3;

const asn1SccPusSubserviceType pus_TM_23_4_reportFileAttributes = 4;

const asn1SccPusSubserviceType pus_TC_23_14_copyFile = 14;
